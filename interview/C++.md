

**1. \#include\<xxx\>的作用，#include\<xxx\>和#include \"\"的区别，#inlcude<xxx.h>的作用**。

**2. sizeof从什么时候开始计算值的，它是函数吗？**

**3. 什么是struct 对齐？**
```C++  
struct A{
    char a;
    double b;
    int c;
}
```  
请问`siezof(A) == ?`，`sizeof(struct A)`最小值应该是？

答：变量对齐要1+7+8+4 = 20字节，但是结构体中占用最大空间类型的是double, sizeof(double) == 8，所以还要结构体对齐，大小要是8的倍数，则对齐20 + 4 = 24字节，综上sizeof(struct A) == 24。

**4. extern "C"{}作用是什么？**
因为C++在编译的时候会对函数名字做改变，而extern "C" {...} 告诉编译器这段代码使用C风格编译成汇编。
一般用法，在头文件里的函数声明中：extern "C" {函数声明}。    

**5. 构造函数能够是虚函数，为什么？析构函数呢？**
答：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针(vptr可以参考C++的虚函数表指针vptr)指向，该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，但此时vptr还没有初始化。
析构函数通常都是virtual的，因为子类可能申请了资源，如果父类指针没有调用子类析构函数那么可能存在资源无法释放的问题。

**6. 说说C++对象的存储空间**  
答：  
(1) 空对象: 1 字节
(2) 只有成员变量: 成员变量的空间。  
(3) 静态变量: 不占用对象存储空间，存放在数据段。
(4) 成员函数: 不占用空间。存放在.text段  
(5) 存在成员函数、虚函数但是没有成员变量: vptr的大小，64位机器是8字节。vptr是虚函数入口地址表指针，指向虚函数入口地址表。
(6) 当继承链上有多个虚函数，则要有多个vptr。在多继承层次结构中，创建的虚函数表指针（vptr）的确切数目是继承横向的分支数。(A -> B -> C)， sizeof(C) == 1 * sizeof(vptr)。
详情阅读：


**7. 说说C++的访问控制符的作用。**
(1) 修饰成员变量
(2) 访问控制符

**8. 下面代码编译运行结果是什么，为什么？**  
```C++
class A {
private: 
    int value;

public:
    A(int n){value = n;}
    A(A other) {value = other.value;}

    void print(){cout<<value<<endl;}    
}

int main(){
    A a = 10;       
    A b = a;
    b.print();
    return 0;
}
```
答：编译失败，因为拷贝构造函数A(A other) 传入的是A的一个实例，那么会形成无限递归调用，编译器能够提前检查出来，所以会编译失败。正确的形参是A(const A & other)。  


**9. 什么是单例模式？用C++实现一个单例模式**  
在程序运行时，保证一个类只有至多一个实例的模式。  

```C++
#include <mutex>

class Single {
private:
    mutex mu;
    Single(){/* ... */}

public:
    static Single * instance;

    Single *GetInstance(){
        if(instance == nullptr){
            mu.lock()
            if(instance == nullptr){
                instance = new Single();
            }
            mu.unlock()
        }
        return instance;
    }

}
Single::instance = nullptr;
```

C++ 11可以使用local static，局部静态。因为C++11后局部静态成了线程安全的，只有当构造函数结束时另一个进程才可访问。  

改成：  
```C++
class Singleton
{
private:
	Singleton() { };
	~Singleton() { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton& getInstance() 
        {
		static Singleton instance;
		return instance;
	}
};
```
**10. 虚函数是如何实现的？**  
答：当一个类带有虚函数时，编译器会为该类构造一个虚函数表，它是一个指针数组，用于存放每个虚函数的入口地址。编译器在进行动态关联事，自底向上搜索在不同继承树上生成的虚函数表里名称类型相同的函数。

**11. 讲讲g++生成可执行文件的过程**
答：分为预处理、编译、汇编、链接。预处理就是将头文件拼接到.cpp文件里、将宏定义展开，生成.i文件。编译就是将C++语言生成进行词法分析、语法分析、语义分析和编译优化、中间语言生成、目标代码生成等过程，然后生成汇编语言.S文件。汇编过程就是将汇编文件生成可重定向目标文件.o文件，链接就是将.o文件和静态库文件合并成可执行文件，它包括地址和空间分配、符号决议和重定位。  

**12. 讲讲静态库和.o文件生成可执行文件的具体过程。**
参考《CSAPP》

**13. LL文法和LR文法，编译器的前端和后端是什么？**
答：LL文法是自顶向下的文法，LL(1)指的是向后看一个字符再规约。LR文法是自底向上规约的文法，LR(1)是指向后看一个字符再规约。编译器前端指的是生成与机器无关的中间代码，编译器后端指的是生成与机器相关的汇编代码。

**14. 静态链接库与动态链接库有什么区别？**
答：静态链接库是在链接阶段生成的，它会打包进可执行文件中。动态链接是在运行时加载到程序中，编译链接时只需要占位符标记即可。静态链接库一般用.a表示，动态链接库一般用.so表示。  
静态库升级需要重新编译整个程序，动态库不需要。

**15. 讲讲动态链接库加载过程**
答：当在shell中键入一个命令时，内核会创建一个新的进程，在往这个新的进程里加载可执行程序的代码段和数据段后，也会加载进动态连接器(/lib/ld-linux.so符号链接所指向的那个程序，它本身就是一个动态库)的代码段和数据。在这之后内核将控制传递给动态链接库的代码，动态链接库负责加载该命令应用程序所需使用的各种动态库，加载完毕后动态连接器才将控制传递给应用程序的main函数。


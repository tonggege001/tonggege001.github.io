---
layout: post  
title: 2021-10-25-Redis设计与实现
date: 2021-10-25
categories: blog
tags: [Redis,数据库,技术]
description: Redis设计与实现
---  


# 2-简单动态字符串  

Redis不使用C语言的字符串对象，而使用自己定义的Simply Dynamic String(SDS，简单动态字符串)。  

## 2.1 SDS 定义  
```c
struct sdshdr {
    // 记录数组中已经使用的字节数量
    // 等于SDS所保存字符串的长度
    int len;

    // 记录buf数组中未使用字节的数量
    int free;

    // 字节数组  
    char buf[];
};
```  
```mermaid
graph TB;
  A[sdshdar, len=5, free=0]-->B[Redis'\0']  
```  
Redis还是遵守了C字符串以空字符结尾的管理，但是并不计算在len中。这样做是可以重用C语言函数。
优势：  
* 常数复杂度获取字符串长度
* 杜绝缓冲区溢出
* 减少修改字符串时带来的内存重分配次数（空间预分配、惰性空间释放）  
* 保证二进制安全，比如一些用户会使用字符串保存二进制数据，那么数据中间含有大量'\0'，使用SDS而不是使用C可以保证保存的数据是完整的。  

# 3-链表  
每个链表的节点都是使用listNode结构来表示：  
```C  
typedef struct listNode {
    // 前驱节点
    struct listNode * prev;
    //后继节点  
    struct listNode * next;
    // 节点的值
    void * value;
} listNode;
```  

多个listNode可以通过prev和next指针组成双端列表。list结构：  
```C  
typedef struct list {
    // 表头  
    listNode * head;

    // 表尾  
    listNode * tail;

    // 链表节点数  
    unsigned long len;

    // 节点值复制函数  
    // dup是一个指针，指向一个函数，函数的返回值是void *
    void * (*dup)(void * ptr);

    // 节点值释放函数  
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void * ptr, void * key);
} list;
```  
* dup函数用于复制链表节点所保存的值；  
* free函数用于释放链表节点所保存的值；
* match函数则用于对比链表节点所保存的值和另一个输入值是否相等。

# 4-字典  
字典又称为符号表、映射(map)，是用来保存键值对的抽象数据结构。Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。  

字典使用的哈希函数是MurmurHash算法，并使用链地址法来解决冲突，多个哈希节点用next字段指向下一个节点。  

当哈希表保存的键值对数量太多或太少时，程序就要对哈希表的大小进行相应的扩展或收缩。这个操作叫rehash，步骤如下：  
1. 字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量。如果执行的扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used\*2的$2^n$。如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的$2^n$  
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上，rehash是指重新计算哈希值和索引值，然后将兼职对放置到ht[1]哈希表的指定位置上。
3. 当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash作准备。  

事实上redis采用的是渐进式rehash，也就是多次rehash而不是一次全部迁移。渐进式rehash详细步骤如下：  
1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序出了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashindex属性的值增1。
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性值设置为-1，表示rehash操作完毕。  

# 5-跳跃表  
跳表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下跳表可以和平衡二叉树相媲美，并且因为跳跃表的实现比平衡树要来的更为简单。  

Redis使用跳跃表作为有序集合键的底层实现之一。Redis只有在实现**有序集合键**和**集群节点**中用作内部数据结构，除此之外跳表在Redis内没有其他用途。  


跳跃表的实现，参考原论文"Skip Lists: A Probabilistic Alternative to Balanced Trees"，[链接](https://homepage.divms.uiowa.edu/~ghosh/skip.pdf).  

## 跳跃表  
<img src="../images/20211025/1.png" style="width: 600px; display: block; margin: 0 auto;" />

如果每2个节点都有一个指针指向距离为2的下一个节点，那么只需要检查不多于ceil(n/2)+1的节点；如果每4个节点都有一个指针指向距离为4的下一个节点，那么只需要检查不多余ceil(n/4)+1的节点；如果每第 $2^i$个节点都有一个指针指向距离为$2^i$的下一个节点，那么检查的节点数可以被降低到ceil($\log_2n$)。这个数据结构可以用来加快查找。  

有k个前向指针的节点被称为k级节点。如果每$2^i$个节点有一个节点，这个节点拥有$2^i$个前向指针，那么节点的等级分布可以如下：50%的概率1级节点，25%的概率是2级节点，12.5%的概率是3级节点，以此类推。  

但是如果严格这样执行，将会产生一个问题，插入和删除的时候需要修改大量的前向指针，尤其是高等级节点需要修改的节点指针会更多，显然这样是不能够接受的。

**跳跃表的做法是转化为概率方法，节点的级别是随机选择的，但是节点等级的概率分布与严格执行时节点等级的概率分布一致。** 这样做的好处是可以就地修改更高级别的指针，而不用对每一等级的节点都进行修改。所以我们需要对严格执行的条件进行修改：**一个节点的第i个前向指针指向下一个同等级或更高级别的节点，而不是下一个距离为$2^{i-1}$的节点。**节点的等级在创建的时候按照严格执行时的概率分布随机指定（也就是50%概率是1级节点，25%概率是2级节点，12.5的概率是3级节点...）。  

## 跳跃表的各种操作算法
每一个元素被表示为一个节点，节点的等级是插入时随机选择的并且与节点的数量无关。一个等级为i的节点有i个前向指针，被索引为1到i。对于每一个节点，我们不需要存储节点的等级，而是使用一个全局的MaxLevel标识。列表的等级是由当前列表中最大节点的等级所表示(如果是空表则为1)。表头节点拥有MaxLevel个节点，并且表头节点中大于列表等级的指针全部设置为NIL。  

### 初始化  
一个NIL节点被分配并且拥有一个大于所有合法key数值的key。所有列表中level的指针全部指向NIL，列表的等级设置为1.  

### 搜索算法  
从头节点的最高级别的前向指针开始遍历，如果当前级别的下一个节点小于目标值，则将指针移动到下一个级别。当在前向指针的当前级别无法取得更多进展时，搜索将向下移动到下一个级别。 当我们无法在第 1 级取得更多进展时，我们必须立即位于包含所需元素（如果它在列表中）的节点前面。算法如下：  

<img src="../images/20211025/2.png" style="width: 500px; display: block; margin: 0 auto;" />  

### 插入和删除算法  
<img src="../images/20211025/3.png" style="width: 600px; display: block; margin: 0 auto;" />  

我们需要首先搜索出需要插入节点在列表的位置，一个向量 update 在搜索中被维护，update[i]包含一个指针，这个指针指向了当前搜索中最右侧的等级为i或者更高的节点，当搜索结束时，这个指针指向着插入点左侧的节点。  

当一个新节点的等级大于从头节点到该节点的最大等级时，需要修改头节点对应最大等级的指针，将其指向本节点。（因为头节点较大的指针可能指向新插入节点的后侧，也可能指向NIL）。如果删除元素后，我们判断是否删除了列表中最大等级的节点，如果是，则需要将列表等级-1.算法如下：  

<img src="../images/20211025/4.png" style="width: 450px; display: block; margin: 0 auto;" />  

### 节点的等级选择  
节点等级是随机选择的，并且要符合严格执行跳表时的等级分布，算法如下：  
```c
int randomLevel(){
    int newLevel = 1;

    // random range in (0, 1)
    while (random() < p){
        newLevel = newLevel + 1
    }

    return min(newLevel, MaxLevel);
}
```  
(注意，级别的生成不依赖于元素数量)。  

### 处理过大等级的搜索  
如果新节点生成的等级远高于当前列表的等级，那么将从头节点中最大等级开始的指针进行搜索，但这将导致很多无用的操作，例如头节点的指针是(1, 2, 4, 8, NIL, NIL, NIL, 128)，那么搜索将从128开始，并且搜索失败时将额外遍历三个无用的NIL，这将导致一些不必要的开销。解决方法：  
* 不管，就这么执行
* 产生的等级如果大于当前列表等级，那么就让产生的等级等于当前列表等级+1. 

其余复杂度分析及概率分析详见原始论文。  

# 8-对象  
Redis并没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。没中对象都用到了至少一种数据结构。  

* Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；
* Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当条件下，通过让多个数据库键共享同一个对象来节约内存。
* Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

## 字符串实现原理  
字符串底层使用SDS，优势是：  
* 获取字符串长度的复杂度为 O(1)；直接可通过 len 属性获得字符串的长度。
* 防止 buf 存储内容溢出的问题；每次增加字符串的长度的时候先检查 free 属性是否能存下要增加的字符串的长度，如果不够，则先对 buf 数组扩容，然后在将内容存入 buf 数组中。
* 空间预分配和空间惰性释放；SDS 会预先分配一部分空闲空间，当字符串内容添加时不需要做空间申请的工作，当字符串从 buf 数组中移除时，空闲出来的空间不会立马被内存回收，防止新增字符串的内容写入时空间不够而临时申请空间。  

|编号|命令|解释|
|:----:|:----:|:----:|
|1|SET key value|设置指定 key 的值|
|2|GET key|获取指定 key 的值。|
|3|GETRANGE key start end|返回 key 中字符串值的子字符|
|4|GETSET key value|将给定 key 的值设为 value ，并返回 key 的旧值(old value)。|
|5|GETBIT key offset|对 key 所储存的字符串值，获取指定偏移量上的位(bit)。|
|6|MGET key1 [key2..]|获取所有(一个或多个)给定 key 的值。|
|7|SETBIT key offset value|对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。|
|8|SETEX key seconds value|将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。|
|9|SETNX key value|只有在 key 不存在时设置 key 的值。|
|10|SETRANGE key offset value|用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。|
|11|STRLEN key|返回 key 所储存的字符串值的长度。|
|12|MSET key value [key value ...]|同时设置一个或多个 key-value 对。|
|13|MSETNX key value [key value ...]|同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。|
|14|PSETEX key milliseconds value|这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。|
|15|INCR key|将 key 中储存的数字值增一。|
|16|INCRBY key increment|将 key 所储存的值加上给定的增量值（increment） 。|
|17|INCRBYFLOAT key increment|将 key 所储存的值加上给定的浮点增量值（increment） 。|
|18|DECR key|将 key 中储存的数字值减一。|
|19|DECRBY key decrement|key 所储存的值减去给定的减量值（decrement） 。|
|20|APPEND key value|如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。|

## List实现原理 
ZipList(压缩列表)和LinkedList，初始化的List使用ZipList，当不满足下列条件之一时会被转位LinkedList：  
* List 中存储的每个元素的长度小于64Byte
* 元素个数小于512

ZipList 的优缺点比较
优点：内存地址连续，省去了每个元素的头尾节点指针占用的内存。  
缺点：对于删除和插入操作比较可能会触发连锁更新反应，比如在 list 中间插入删除一个元素时，在插入或删除位置后面的元素可能都需要发生相应的移动操作。

|编号|命令|解释|
|:----:|:----:|:----:|
|1|BLPOP key1 [key2 ] |timeout| 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。|
|2|BRPOP key1 [key2 ] timeout|移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。|
|3|BRPOPLPUSH source destination timeout|从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。|
|4|LINDEX key index|通过索引获取列表中的元素|
|5|LINSERT key BEFORE|AFTER pivot value|在列表的元素前或者后插入元素|
|6|LLEN key|获取列表长度|
|7|LPOP key|移出并获取列表的第一个元素|
|8|LPUSH key value1 [value2]|将一个或多个值插入到列表头部|
|9|LPUSHX key value|将一个值插入到已存在的列表头部|
|10|LRANGE key start stop|获取列表指定范围内的元素|
|11|LREM key count value|移除列表元素|
|12|LSET key index value|通过索引设置列表元素的值|
|13|LTRIM key start stop|对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。|
|14|RPOP key|移除列表的最后一个元素，返回值为移除的元素。|
|15|RPOPLPUSH source destination|移除列表的最后一个元素，并将该元素添加到另一个列表并返回|
|16|RPUSH key value1 [value2]|在列表中添加一个或多个值|
|17|RPUSHX key value|为已存在的列表添加值|

## Set实现原理  
Set 集合采用了intset整数集合和字典两种方式来实现的，当满足如下两个条件的时候，采用整数集合实现；一旦有一个条件不满足时则采用字典来实现。
* Set 集合中的所有元素都为整数
* Set 集合中的元素个数不大于 512（默认 512，可以通过修改 set-max-intset-entries 配置调整集合大小）  

|编号|命令|解释|
|:----:|:----:|:----:|
|1|SADD key member1 [member2]|向集合添加一个或多个成员|
|2|SCARD key|获取集合的成员数|
|3|SDIFF key1 [key2]|返回第一个集合与其他集合之间的差异。|
|4|SDIFFSTORE destination key1 [key2]|返回给定所有集合的差集并存储在 destination 中|
|5|SINTER key1 [key2]|返回给定所有集合的交集|
|6|SINTERSTORE destination key1 [key2]|返回给定所有集合的交集并存储在 destination 中|
|7|SISMEMBER key member|判断 member 元素是否是集合 key 的成员|
|8|SMEMBERS key|返回集合中的所有成员|
|9|SMOVE source destination member|将 member 元素从 source 集合移动到 destination 集合|
|10|SPOP key|移除并返回集合中的一个随机元素|
|11|SRANDMEMBER key [count]|返回集合中一个或多个随机数|
|12|SREM key member1 [member2]|移除集合中一个或多个成员|
|13|SUNION key1 [key2]|返回所有给定集合的并集|
|14|SUNIONSTORE destination key1 [key2]|所有给定集合的并集存储在 destination 集合中|
|15|SSCAN key cursor [MATCH pattern] [COUNT count]|迭代集合中的元素|


## Zset（有序集合）的实现原理  
Zset 底层同样采用了两种方式来实现，分别是 ZipList 和 SkipList。当同时满足以下两个条件时，采用 ZipList 实现；反之采用 SkipList 实现。
* Zset 中保存的元素个数小于 128。（通过修改 zset-max-ziplist-entries 配置来修改）
* Zset 中保存的所有元素长度小于 64byte。（通过修改 zset-max-ziplist-values 配置来修改）

|编号|命令|解释|
|:----:|:----:|:----:|
|1|ZADD key score1 member1 [score2 member2]|向有序集合添加一个或多个成员，或者更新已存在成员的分数|
|2|ZCARD key|获取有序集合的成员数|
|3|ZCOUNT key min max|计算在有序集合中指定区间分数的成员数|
|4|ZINCRBY key increment member|有序集合中对指定成员的分数加上增量 increment|
|5|ZINTERSTORE destination numkeys key [key ...]|计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中|
|6|ZLEXCOUNT key min max|在有序集合中计算指定字典区间内成员数量|
|7|ZRANGE key start stop [WITHSCORES]|通过索引区间返回有序集合指定区间内的成员|
|8|ZRANGEBYLEX key min max [LIMIT offset count]|通过字典区间返回有序集合的成员|
|9|ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]|通过分数返回有序集合指定区间内的成员|
|10|ZRANK key member|返回有序集合中指定成员的索引|
|11|ZREM key member [member ...]|移除有序集合中的一个或多个成员|
|12|ZREMRANGEBYLEX key min max|移除有序集合中给定的字典区间的所有成员|
|13|ZREMRANGEBYRANK key start stop|移除有序集合中给定的排名区间的所有成员|
|14|ZREMRANGEBYSCORE key min max|移除有序集合中给定的分数区间的所有成员|
|15|ZREVRANGE key start stop [WITHSCORES]|返回有序集中指定区间内的成员，通过索引，分数从高到低|
|16|ZREVRANGEBYSCORE key max min [WITHSCORES]|返回有序集中指定分数区间内的成员，分数从高到低排序|
|17|ZREVRANK key member|返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序|
|18|ZSCORE key member|返回有序集中，成员的分数值|
|19|ZUNIONSTORE destination numkeys key [key ...]|计算给定的一个或多个有序集的并集，并存储在新的 key 中|
|20|ZSCAN key cursor [MATCH pattern] [COUNT count]|迭代有序集合中的元素（包括元素成员和元素分值）|

## Hash的实现原理  
Hash 底层实现采用了 ZipList 和 HashTable 两种实现方式，相信看到这里大家都比较轻车熟路了，下面来看看。Hash 结构当同时满足如下两个条件时底层采用了 ZipList 实现，一旦有一个条件不满足时，就会被转码为 HashTable 进行存储。

* Hash 中存储的所有元素的 key 和 value 的长度都小于 64byte。（通过修改 hash-max-ziplist-value 配置调节大小）
* Hash 中存储的元素个数小于 512。（通过修改 hash-max-ziplist-entries 配置调节大小）


|编号|命令|解释|
|:----:|:----:|:----:|
|1|HDEL key field1 [field2]|删除一个或多个哈希表字段|
|2|HEXISTS key field|查看哈希表 key 中，指定的字段是否存在。|
|3|HGET key field|获取存储在哈希表中指定字段的值。|
|4|HGETALL key|获取在哈希表中指定 key 的所有字段和值|
|5|HINCRBY key field increment|为哈希表 key 中的指定字段的整数值加上增量 increment 。|
|6|HINCRBYFLOAT key field increment|为哈希表 key 中的指定字段的浮点数值加上增量 increment 。|
|7|HKEYS key|获取所有哈希表中的字段|
|8|HLEN key|获取哈希表中字段的数量|
|9|HMGET key field1 [field2]|获取所有给定字段的值|
|10|HMSET key field1 value1 [field2 value2 ]|同时将多个 field-value (域-值)对设置到哈希表 key 中。|
|11|HSET key field value|将哈希表 key 中的字段 field 的值设为 value 。|
|12|HSETNX key field value|只有在字段 field 不存在时，设置哈希表字段的值。|
|13|HVALS key|获取哈希表中所有值。|
|14|HSCAN key cursor [MATCH pattern] [COUNT count]|迭代哈希表中的键值对。|

## 内存回收  
因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个**引用计数**技术实现的内存回收机制，通过这一机制，程序可以通过对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。  
每个对象的引用信息由RedisPbject结构的refcount属性记录：  
```c  
typedef struct redisObject {
    // ...
    // 引用计数  
    int refCount;
    // ...
} robj;
```  

对象的整个生命周期操作部分如下：  
```c
// 创建一个字符串对象 s, 对象的引用计数为1
robj * s = createStringObject(...)

// 对象 s 执行各种操作 ...

// 将对象s的引用计数减一，使得对象的引用计数变为0
// 导致对象s被释放
decrRefCount(s)
```  

## 对象共享  

除了用于实现引用计数内存回收机制外，对象的引用计数属性还带有对象共享的作用。相同值的对象共享同一个引用，引用计数+1.  

## 过期键删除策略  
数据库的键都保存到过期字典中，那么一个键过期了，理论上有三种删除策略：  

* 定时删除：设置过期时间的同时设置一个定时任务到点自动删除。
* 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除键；如果没有过期，就返回该键。  
* 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。  

Redis实际上使用的是**定期删除**和**惰性删除**两种结合。  

# 10-Redis 持久化  
Redis是一个内存数据库，它将数据库保存到内存里面，所以如果不想办法将存储在内存的数据库状态保存到磁盘，则当数据库进程崩溃有可能导致数据都是。  

RDB持久化既可以手动执行，也可以配置服务器定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。  

`SAVE`命令阻塞Redis进程来进行保存，`BGSAVE`命令会派生一个子进程来创建RDB文件，而服务器进程继续处理其他命令请求。  
伪代码表示二者区别：  
```python  
def SAVE():
    rdbSAVE()

def BGSAVE():
    pid = fork()
    if pid == 0:
        rdbSave()
        signal_parient()
    elif pid > 0:
        # 父进程继续处理命令请求，并通过轮询等待子进程的信号
        handle_request_and_wait_signal()  
    else:
        handle_fork_error()
```

> 因为AOF持久化更新频率比RDB高，所以服务器若开启了AOF持久化，则优先读取AOF文件来还愿状态。只有AOF持久化功能处于关闭状态，服务器才会使用RDB文件还原。  

`BGSAVE`执行期间，`SAVE`，`BGSAVE`，`BGREWRITEAOF`命令被禁止。

## 周期性保存  
Redis可以设置保存条件：`save 900 1`，每900毫秒内发生1次修改就保存。Redis检查保存条件是否满足方法：  

Redis服务器有一个周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查`save`选项所设置的保存条件是否满足。  

 





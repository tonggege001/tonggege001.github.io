---
layout: post  
title: 2021-12-16-数据库系统原理笔记
date: 2021-12-16
categories: blog
tags: [数据库,笔记]
description: 2021-12-16-数据库系统原理复习，DBMS，范式
---  

# 1. 数据库管理系统  
## 1.1 DBMS的数据子语言  
* **数据定义语言**（DDL）：负责数据模式定义与数据的物理存取模式。
* **数据操作语言**（DML）：负责数据的操作处理，例如查询、增加、删除和修改。
* **数据控制语言**（DCL）：负责数据完整性和安全性的定义与检查，同时完成并发控制和故障恢复职能。

<img src="../images/20211216/2.jpg" style="display: block; margin: 0 auto; width:500px;"/>

### 查询更新部分  
* 查询/更新命令由**查询编译器**进行语法分析和优化处理。
* 将编译结果（查询计划）送交**执行引擎**，执行引擎向资源管理器发出相应的获取分块数据请求（通常为关系表中的元组集合）。
* 资源管理器确定数据文件，包括格式和元组子集大小和索引文件
* 数据请求被转换为**页请求**，页请求被交于**缓冲管理器**(buffer manager)。缓冲区与磁盘块的数据传输单位为页。

查询编译器：基本功能时将查询请求转化为查询树的内部形式生成查询计划，查询计划实际上就是基于数据的操作序列，在关系数据库管理系统中通常使用“关系代数”运算实习i爱你查询计划中的相应操作。  

### 事务管理部分  
事务要满足原子性、隔离性、持久性和一致性，一个查询或更新本身也可以看成一个事务。事务管理器通常分为**并发控制管理器**和**日志/故障恢复管理器**两个部分。  

并发控制管理器负责原子性、隔离性和一致性，日志/恢复管理器用以保障事务持久性。  

## 1.2 数据库模式结构  

### 数据抽象
静态抽象：物理层面、逻辑层面、视图层面。

### 动态抽象  
数据实例、数据模式  
  
### 三级模式  
* 模式：也称逻辑模式或概念模式，可以看作内模式与外模式之间的层次。**实际上模式是全体用户的公共数据视图**，数据库中的模式是唯一的，DBMS提供逻辑模式的DDL来定义模式，模式的定义不仅设计数据逻辑结构和数据之间的联系，还设计数据有关的安全性和完整性要求。
*******
* 外模式：用户看到的数据视图，外模式与某一具体应用有关的数据的逻辑结构和特征描述，模式给出系统的全局数据描述，**外模式则给出每个用户局部描述**，外模式由模式推导而出，通常可以看作模式的一个子集。
******
* 内模式：**数据库物理结构和存储方式的描述**。内模式由内部记录中的各个类型的值组成，他定义了数据库中的各种数据记录的物理表示、存储结构与物理存取方法，如数据存储的文件结构、索引、集簇等存取方式和路径等。一个数据库只有一个内模式。内模式并不是物理底层，它不关注物理块和页，不考虑具体磁盘柱面和大小，实际上还是一种抽象。

### 两级映射  
模式/内模式映射和外模式/模式映射。

### 数据模型  
* 概念模型：也称为信息模型，面向用户容易理解的现实世界特征的数据抽象
* 逻辑模型：结构数据模型，按照计算机系统观点对数据和信息进行建模（层次模型、网状模型、关系模型、面向对象模型）。
* 物理模型：（缓存页、索引文件）  

# 2. 关系模型与关系运算  

**键**  
* 超键：在给定关系R中，能够**唯一标识**各元组的属性集合为R的超键。
* 候选键：不含多余属性的超键为候选键，候选键有时也称为键。
* 主键：瓜泥中可能有多个候选键，选定了用于标识的候选键称为主键。
* 外键：如果一个关系$R_1$的一个属性子集A是另一个关系$R_2$的主键，但不是$R_1$本身的主键，则称A是关系$R_1$的外键，其中$R_1$称为依赖关系，$R_2$称为被依赖或参照关系。

**关系运算**：分为关系代数和关系演算。  

### 完整性约束  
* 实体完整性约束：主键不能为空，对主键的约束。  
* 参照完整性约束：某一关系R内的外键的所有元素，都必须是另一关系$R_2$的某一列已经存在的元素。
* 用户定义完整性约束：符合数据内容的一些约束。

## 2.2 关系代数  

**插入操作 - 集合并**  
$$
R \cup S = \{t | t \in R \vee t \in S \}
$$

**删除操作 - 集合差**  
$$
R - S = \{t | t \in R \wedge t \notin S\}
$$  

**修改操作 - 差与并的符合**  
设需要修改的集合为$R_1$，修改后的集合为$R_2$，则修改操作为$(R-R_1)\cup R_2$  

基于查询的基本运算：  

**关系属性指定 - 投影操作**  
投影是一元关系运算，用于选择某个关系上感兴趣的某些列，将这些列组成新关系。  

注意，投影关系会进行去重，当选择的列组成新的关系时，重复的会被去掉。  
$$
\Pi_{A,D,C}(R)
$$
有时候简写为$\Pi_{1,4,3}(R)$  

**元组选定 - 选择操作**  
选择也是一元关系，用于选取关系上感兴趣的行（满足条件F）。  
$$
\sigma_F(R) = \{t|t\in R \wedge F(t) = true\}
$$

**关系集成 - 广义笛卡尔积**  
$$
R \times S = \{t | t=<t^r, t^s>\wedge t^r \in R \wedge t^s \in S\}
$$

上面时关系运算的五种基本模式，实际上通过上面的运算还可以推导出另外两种运算：交和除法运算。  

**交操作**  
$$
R \cap S = R - (R - S) = S - (S - R)
$$

**除法操作**  
[讲解](https://blog.csdn.net/t_1007/article/details/53036082)

一个简单的例子就是学生选课表R(student_no, class_no)，和所有课程的表S(class_no)，那么选了**所有课**的学生T(student_no)有：$R / S = T$.  

A/B 除法就是找出A中特有的列，然后在特有的列上找出特有的行（特有的行中共必须包含所有公有的列的元素值）。  

**连接操作**  
设关系R,S,$\theta$是一个运算，则链接操作定义为：  
$$
R \bowtie_{i \theta j} S = \sigma_{i\theta j}(R \times S)
$$  
如果$\theta$是=，则是等值连接。

MySQL的三种连接：内连接，左连接，右连接。
|名称连接|说明|  
|:----:|:----:|
|INNER JOIN| 获取两个表中字段匹配关系的记录(自然连接)|
|LEFT JOIN|左表的该字段每个值都取定，右表按照相等连接，没有左表子段的则连接后该字段为NULL|
|RIGHT JOIN|与LEFT类似，获取右表所有记录，即使左表没有对应匹配的记录|


## 2.4 查询优化  
一般来说，SELECT 语句对应投影运算，FROM语句对应笛卡尔积运算，WHERE语句对应选择运算。  

### 查询优化器  
1）物理优化，增加索引等。
2）规则优化，先选择、投影后连接。
3）代价估算优化，对多个候选策略逐个执行代价估算，选择代价最小的执行。  

### 关系代数的等价变换  
* 笛卡尔积结合律，F连接结合律，自然连接结合律
* 笛卡尔积、F连接、自然连接满足交换律
* 选择运算满足交换律：$\sigma_{F_1}(\sigma_{F_2}(E)) = \sigma_{F_2}(\sigma_{F_1}(E))$
* 基于合取条件的分解公式：$\sigma_{F_1 \wedge F_2}(E) = \sigma_{F_1}(\sigma_{F_2}(E))$
* 投影运算串连接。
* 选择和投影运算可交换
* 先选择再求并
* 先选择再做差
* 先选择再笛卡尔积
* 先投影再求并
* 先投影再求笛卡尔积
* 笛卡尔积+选择等价于F连接操作

# 3. SQL 语言  

## 数据定义  
|数据对象|定义|删除|修改|
|:----:|:----:|:----:|:----:|
|模式|CREATE SCHEMA|DROP SCHEMA|ALTER SCHEMA|
|基本表|CREATE TABLE|DROP TABLE|ALTER TABLE|
|视图|CREATE VIEW|DROP VIEW|ALTER VIEW|
|索引|CREATE INDEX|DROP INDEX|ALTER INDEX|

### 创建表  
```SQL
CREATE TABLE <表名>(
    <列名><数据类型>[完整性约束]
    [,<列名><数据类型>[完整性约束]]
    ...
    [, <表级完整性约束>]
)
```  
```SQL  
CREATE TABLE S(
    S# CHAR(4) NOT NULL UNIQUE,
    Sn SMALLINT,
    Sa CHAR(2),
    Sex CHAR(2),
    Sd CHAR(20),
    Fk CHAR(10),
    PRIMARY KET(S#),
    FOREIGH KEY(Fk) REFERENCE K_TABLE(Fk) ON DELETE CASCADE,
    CHECK(Sa BETWEEN 15 AND 25);
)
```  
**参照完整性约束里ON DELETE**说明当参照表里的主属性被删除时，可采用如下方法保证完整性：  
* 选用RESTRICT选项：参照表的主属性不能被删除。
* CASCADE：级联删除本表对应的行
* SET NULL：该列的参照被设置成NULL

### 更新表结构  
```SQL  
ALTER TABLE <表名> ADD <新列名> <数据类型>[完整性约束条件]

ALTER TABLE <表名> DROP <属性列名>[CASCADE|RESTRAIN]

ALTER TABLE <表名> MODIFY <属性列名> <类型>

ALTER TABLE <表名> ADD PRIMARY KEY(<列名表>)

ALTER TABLE <表名> DROP PRIMARY KEY(<主键名>)
```
删除列的CASCADE表示：删除该列时，所有引用到该列的视图和约束也要一起自动删除；RESTRAIN表示没有引用该列的视图和约束时才允许删除，否则就拒绝删除操作。  

### 删除表  
```SQL  
DROP TABLE <表名> [CASCADE|RESTRICT]
```  
CASCADE: 删除表的同时对应删除视图和约束
RESTRICT: 要求在没有视图或约束引用S的属性列时才能撤销，否则拒绝撤销。  

### 索引定义  
```SQL  
CREATE [UNIQUE][CLUSTERED] INDEX <索引名> 
    ON <表名>(<列名>[排序方式][,<列名>[,<排序方式>]])
```  
排序方式可以指定ASC或者DESC表示升序或者降序。  

例如：  
```SQL  
CREATE UNIQUE INDEX_S_XSNO S(S#);  

CREATE INDEX SC_XSC ON SC(S#, C#);

DROP INDEX <索引名>
```

## 3.3 数据查询  
|查询子句|SLECT|FROM|WHERE|GROUP BY|ORDER BY|
|:--:|:--:|:--:|:--:|:--:|:--:|
|对应运算|投影|连接|选择|分组|排序|

```SQL  
SELECT [ALL|DISTINCT] <属性名>[, 属性名]...  
FROM <表名或视图名>[,<表名或视图名>]...
[WHERE <逻辑表达式>]
[GROUP BY <属性名1> [HAVING <逻辑表达式>]]
[ORDER BY <属性名2>[ASC | DESC]]
```  
SELECT子句中输出可以是属性名称或聚集函数(AVG、COUNT、MAX、MIN和SUM)取值；DISTINCT选项用于保证查询的结果中不存在重复元组；若使用GROUP BY子句，则结果按<属性名1>的值进行分组，该属性取值相等的元组为一个组，每个组产生结果表中的**一个记录**。通常会在某组中使用聚集函数。如果GROUP子句带HAVING短语，则只有满足指定条件的组才予以输出。如果有ORDER子句，则结果还要按<属性名2>的值的升序(ASC)或降序(DESC)排列。  

### SELECT子句  
* SELECT * 表示输出FROM子句中所有关系的全部属性
* 通常情况下SELECT允许查询结果出现重复，所以需要SELECT DISTINCT 去重  
* SELECT子句还可以包含+、-、*、/四则运算，例如：`SELECT 总评成绩 AS 平时成绩*40%+期末成绩*60%`  

### WHERE 子句  
WHERE子句主要表现在：  
(1). 映像语句在WHERE子句中可以**嵌套**。
(2). WHERE子句中逻辑条件不仅有比较关系式，还有集合表达式和一阶谓词公式等。  
||运算符|含义|
|:--:|:--:|:--:|
|集合成员运算|IN, NOT IN | 在集合中/不在集合中|
|字符串匹配运算|LIKE|与-和%进行单个、多个字符匹配|
|空值运算|IS NULL, IS NOT NULL|为空，不能为空|
|比较运算|>, >=, <, <=, =, <>|大于....不等于|
|逻辑运算|AND, OR, NOT|与、或、非|
|谓词运算|EXISTS, ALL, ANY, BETWEEN .. AND ..|存在、所有、任意、在..和..之间|

### FROM 子句  















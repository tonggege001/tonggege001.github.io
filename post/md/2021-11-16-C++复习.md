---
layout: post  
title: 2021-11-16-C++复习
date: 2021-11-16
categories: blog
tags: [C++,编程语言]
description: C++复习
---  

# 2-变量和基本类型

## 2.1 const 关键字  
1. 在全局变量里定义 const 关键字，默认的作用域是本文件；在全局变量里定义非const变量，默认的作用域是整个程序。如果要让const常量作用在整个程序，则需要额外指定extern，例如 `extern const bufSize = 512;`  

2. 如果没有对常量的内存进行引用、指针操作，则它在编译前的预处理阶段就会替换原来的常量为字面量。如果进行了引用、地址操作，则会强行让编译器为其分配内存。

**顶层const**：表示指针本身是个常量。  
**底层const**：指针所指的对象是一个常量。  

```C++  
int * const p1 = &i;        // 这是一个顶层const，不能改变p1的值  
const int ci = 42;          // 这是个顶层const，不能改变ci的值
const int * p2 = &c1;       // 允许改变p2的值，这是一个底层const
const int *  const p3 = p2; // 右边的const是顶层const，左边const是底层const
const & r = ci;             // 用于声明引用的const都是底层const，因为引用本身就不能更改，天然带有顶层const属性
```  

auto会忽略顶层const，而只会保留底层const。  

**decltype**标识符：获得数值的类型。例子：  

```C++
decltype(f()) sum = x;  // 定义sum变量，类型是f的返回值类型，decltype并不调用f，编译期间就能够知道
const int ci = 0;
decltype(ci) x = 0;
decltype((ci)) x = 0;       // 获得的是引用类型，而不是原来的值类型，int&，而不是int
```

## 2.2 引用  
引用也就是变量的别名，主要用作函数的形式参数。

* const 引用是指向const对象的引用。

## 2.3 头文件  
头文件一般包含类的定义、extern变量的声明和函数声明，头文件的内容会被预处理器复制到程序对应的位置。一般要设置头文件保护符，目的是防止多次引用时同一文件下有多重定义：  
```C++  
#ifndef XXX
#define XXX
// 头文件内容  
#endif
```

头文件一般用作声明而不是定义：  
```C++  
extern int ival = 10;           // 有初始化，所以是定义。默认情况下extern可以省略
double fica_rate;               // 没有extern关键字，所以是定义
```

## 2.4 using 声明  
1. using 声明 (using declaration) 是将命名空间中单个名字注入到**当前作用域**的机制，使得在当前作用域下访问另一个作用域下的成员时无需使用限定符 ::  
```C++  
// OK
{
    using std::map
    map<int, std::string> the_map;
}
// ERROR
map<int, std::string> the_map2;
```
using 声明每次只能作用于一个命名空间成员，使用using声明后就不需要在名称前加std::这样的名称空间来。 
当然为了使用所有std或者其他名称空间的内容，你也可以直接using namespace std;

2. using 声明，可以改变派生类对父类成员的访问控制  

```C++  
class Base{
protected:
    int bn1;
    int bn2;
};
 
class Derived: private Base{
public:
    using Base::bn1;
};
 
class DerivedAgain: public Derived{
};
 
int main(){
    Derived d;
    DerivedAgain da; 
    d.bn1 = 1;
    d.bn2 = 2; //error, 'bn2' is a private member of 'Base'
    da.bn1 = 3;  //ok
    std::cout<<d.bn1<<std::endl;
 
    return 0;
}
```  
尽管 Derived 对 base 是私有继承，但通过 using 声明，我们还是可以在 Derived 中访问其成员，且后续的继承同样不受 private 限定的影响。  

3. 使一个命名空间中的 **所有** 名字都在该作用域中可见的机制。这是最常用的方式了。需要注意的是命名冲突问题。  
```C++
#include <iostream>
namespace n1{ 
    int n1_member = 10; 
    int m = 11; 
}
 
int m = 12; 
 
int main(){
    using namespace n1; 
    std::cout<<n1_member<<std::endl;
    //std::cout<<m<<std::endl;  //error 命名冲突
    std::cout<<::m<<std::endl;
 
    int m = 13; //ok, 局部变量屏蔽命名空间变量
    std::cout<<m<<std::endl;
 
    return 0;
}
```
尽管 using指示很方便，但在实际工作中应该尽量避免：它一下子将另一个 namespace 中的成员全部引入了，一不小心就会出现命名空间污染问题。  

4. 类型重定义，取代 typedef `using alias = typename`
```C++
using fun = void (*)(int, int);
//typedef void (*fun)(int, int); //与上一句等价
using int16 = short;
//typedef short int16; //与上一句等价
 
int main(){
    std::cout<<sizeof(int16)<<std::endl;
}
```  
为什么要类型重定义呢？原因是：  
在 C++98/03 中 ，typedef 重定义有一些限制，比如，模板。我们想实现这样一个模板：将一个 int 映射到任意类型，类似于我们想表达这种效果：  
```C++  
typedef std::map<int, int> map_int_t;
typedef std::map<int, std::string> map_str_t;
typedef std::map<int, bool> map_b_t;
//... Others
```  
但是在C++ 98中使用模板必须要这样写：  
```C++
template<typename Val>
struct int_map{
    typedef std::map<int, Val> type;
};
 
int main(){
    int_map<int>::type imap;
 
    return 0;
}
```  
在C++11 中，我们可以使用 using 重定义模板：  
```C++  
template<typename Val>
using int_map_t = std::map<int, Val>;
 
int main(){
    int_map_t<int> imap;
 
    return 0;
}
```  

## 2.5 运算符优先级  

1. `[]` `()` `.` `->`
2. `-` `(type)` `++` `--` `*` `&` `!` `~` `sizeof`
3. `/` `*` `%`
4. `+` `-`
5. `<<` `>>`
6. `>` `>=` `<` `<=`
7. `==` `!=` 
8. `&`
9. `^`
10. `|`
11. `&&`
12. `||`
13. `?:`
14. `=` `/=` `+=` ... `|=`
15. `,`  

## 2.6 指针+1
```C++  
int a;
int * p = &a;
int * q = p + 1;
```  
上面的代码如果p和q转换成int类型，那么可能q比p小4，这是因为栈空间是高地址向低地址增长，p是高地址，p+1代表地址增加一个最小单元，那么p+1一定在低地址，32位系统则可能差四个字节。  

```C++  
int a[3][4];
int (* p)[4] = a;
p = p+1;
```  
上面代码指针+1，地址加（或减，取决于栈空间还是堆）了sizeof(int) * 4。  

## 2.7 类型转换  
C++有隐式类型转换和或提升，也有显式类型转换。 一般int 

自动隐式转换，C在以下四种情况下会进行隐式转换:    
1、算术运算式中，低类型能够转换为高类型。
2、赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。
3、函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。
4、函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。  

优先级：  
char, short -> int -> unsigned -> long -> double;  
float -> double;  

所以当表达式中无符号数和有符号数都被转换为无符号数。

**显示转换**：  
`cast-name<type>(expression)`  

一共有四种类型 ：`static_cast`、`const_cast`、`const_cast`、`reinterpret_cast`  

`static_cast`：任何具有明确定义的类型转换，只要不包含底层const，都可以使用。  

`const_cast`：只能改变const变量的类型：  
```C++  
const char * pc;
char * p = const_cast<char *>(pc)
```  

`reinterpret_cast`：改变指针类型。  
```C++  
int * ip;
char * pc = reinterpret_cast<char *>(ip);
```  

## 2.8 else的就近原则  
if-else 嵌套，else对应的就近原则。  

## 2.9 switch-case内部定义变量  

switch-case中，case内部定义变量不能放在同一层，必须用{}括起来： 
```C++  
case true: {
    string filename;
    int ival = 10;
    int jval;
}
```  
下面的是错误代码，会导致隐式跳过变量的初始化。
```C++  
// 错误代码
case true: 
    string filename;
    int ival = 0;
    int jval;
case false;
    jval = 10;
```  

## 2.10 try-catch异常 
```C++ 
try {
    // 执行添加两个Sales_item  
    // 如果添加失败，代码抛出一个runtime_error异常
}catch(runtime_error err){
    cout<<err.what() <<"Try again Enter y or n"<<endl;
    char c;
    cin >> c;
    if(!cin || c== 'n'){
        break;
    }
}

```
注意：C++没有try-catch-finally，只有try-catch。当有异常发生时，中断当前程序，然后搜索当前是否有error，没有则沿着函数调用链反方向抛出。当都没有找到对应的error，则程序被转为terminate的标准库函数，该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。  

标准库函数提供的部分异常：  
|异常名称|描述|  
|:----:|:----:|  
|exception|最常见问题|
|runtime_error|只有运行时才能检测出问题|
|range_error|运行时的值超出范围|
|overflow_error|计算上溢|
|underflow_error|计算下溢|
|...|...|  

异常类型只返回一个what()的成员函数，该函数没有任何参数，返回一个C风格字符串。  

# 3-函数  

## 3.1 函数传参  
* 当const实参传递给形参时，顶层const被忽略。
* 当不改变参数时，尽量用常量引用，const string &  

**含有可变参数的函数**  
参数一样的时候，可以使用initializer_list：  
```C++  
void error_msg(initializer_list<string> li){
    for(auto beg = li.begin();beg != li.end();beg++){
        cout<<*beg<<endl;
    }
}  

// 调用：  
error_msg({"hello", "world", "!"});  
```  

为了兼容C，则可以用`...`作为省略形参，然后再通过C库varargs变量获得。  

## 3.2 函数返回值和引用  
返回值时，比如string。那么意味着返回值会被拷贝到调用点，因此函数会返回一个副本或者未命名的临时变量。  

如果返回引用，则不会拷贝，例如：  
```C++  
const string & shorterStr(const string & s1, const string & s2){
    return s1.size() <= s2.size()?s1:s2;
}
```

**注意：不要返回局部对象的引用**  
```C++  
// 错误的例子
const string & manip(){
    string ret;
    ...
    return ret;
}
```

## 3.3 函数重载  
函数名相同，形参不同的函数。  
> 形参会忽略顶层const，所以有无顶层const不能区分不同函数。  

```C++  
Record lookup(Phone *);
Record lookup(Phone * const);       // 重复声明！  

Record lookup(Account &);
Record lookup(const Account &);     // 新函数

Record lookup(Account *);
Record lookup(const Account *);     // 新函数
```  

重载函数的匹配：首先选择候选函数，然后选择不需要强制类型转换的最佳匹配，如果都是最佳匹配则报二义性错误。

类的成员函数按照是否是const也可以重载：  
```C++  
Screen & display(std::ostream & os){xxx};
Screen & display(std::ostream & os) const {xxx};    // 正确，可以重载，函数选择会根据调用对象是否是const来选择。
```

**重载与作用域**  
作用域内的函数声明会屏蔽掉作用域外的的重载函数，比如：  
```C++  
void print(const string &);
void print(double);

void fooBar(int val){
    void print(int);        // 新作用域屏蔽了前面两个print

    print("hello");         // ERROR
    print(3);               // 正确  
    print(3.14)；           // 正确，实际调用的是print(int)
}
```  



## 3.4 默认实参  
`string screen(int name, size_type ht=24, size_type wid=80);`  

## 3.5 内联函数  
内联函数就是将它在调用点内联地展开。在函数的返回值前面加上inline即可声明。当然，编译器也可以忽略这个内联的请求。  

## 3.6 调试帮助  
`assert`宏使用：`assert(expr)`，首先对表达式expr进行求值，如果表达式为假则assert输出信息并终止程序执行，如果表达式为真，assert什么都不做。预处理assert宏在cassert头文件中。  

assert行为依赖于NDBUG预处理变量，若定义了NDEBUG，则assert什么也不做。  

NDEBUG还可以用于自己定义变量：  
```C++  
void print(const int ia[], size_t, size){
    #ifndef NDBUG
        // __func__是编译器定义的一个局部静态变量，用于存放函数的名字  
        cerr<< __func__<<": array size is "<<size<<endl;
    #endif
}
```
当然，C++预处理器还定义了以下几个字符串字面值：  
\_\_FILE\_\_: 存放文件名的字符串字面值  
\_\_LINE\_\_: 存放当前行号的整型字面值  
\_\_TIME\_\_: 存放文件编译的时间的字符串字面值
\_\_DATE\_\_: 存放文件编译日期的字符串字面值

## 3.7 函数指针  
指向函数的指针:  
```C++  
bool (*pf)(const string &, const string &);
pf = lengthCompare;
pf = &lengthCompare;        // 上面两者等价，取地址符是可选的
```  

调用函数也可以不用解引用，直接调用`pf(xxx,xxx);`  

当pf=nullptr或者pf=0时，表示该指针没有指向任何一个函数。  

**函数指针作为形参和返回值**  
使用using或者typedef起别名。  

```C++  
typedef decltype(lengthCompare) Func2;

using PF = int(*)(int *, int *);
PF f1(int){
    .....
}

// 等价于  
int (*f1(int))(int *, int *);  

// 使用尾置返回值类型：  
auto f1(int) -> int(*)(int *, int);
```  

# 4-类  
## 4.1 this  
成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用`total.isbn()`，则编译器负责把total的地址给isbn的隐式形参this，可以等价地认为编译器将调用重写成`Sales_data::isbn(&total);`。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符做到这一点，比如this->bookNo简化成bookNo  

**成员函数参数列表后面的const**：修改隐式this的类型为底层const  

## 4.2 成员函数  
我们定义成员函数是在类的外部定义：  
```C++  
double Sale_data::avg_price() const {
    ...
}
```  

**定义一个返回this对象的函数**：注意，返回值必须是左值，所以是返回引用。  
```C++  
Sales_data & Sales_data::combine(const Sales_data & rhs){
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```  

## 4.3 构造函数  
如果没有构造函数，则编译器创建一个默认构造函数。初始化成员：  
* 如果存在类内的初始值，用它来初始化成员
* 否则默认初始化该成员，对象成员没初始化，其值由类决定（栈空间则随机，堆空间则为0）

如果我们定义了构造函数，则编译器不会定义默认构造函数，就需要自己再定义默认构造函数了。  

自动定义默认构造函数：  
```C++  
struct Sales_data{
    Sales_data() = default;
    Sales_data(const std::string &s):bookNo(s){...}  
    Sales_data(std::istream &);         // 定义在类外面，不包含函数体
}
```  

**委托构造函数：** 受委托的函数执行完毕后，接着执行自己的构造函数  
```C++  
class Sales_data {
public: 
// 非委托构造函数使用对应的实参初始化成员
Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt * price){};

// 其余构造函数全部委托给另一个构造函数
Sales_data():Sales_data("", 0, 0){}
Sales_data(std::string s): Sales_data(s, 0, 0){}
Sales_data(stdingLListream & is):Sales_data(){read(is, *this)};
}
```

## 4.4 访问控制与封装  

`private`: 类成员只能由成员函数和友元 (private 类或类) 的友元使用。
`protected`: 类成员可以由成员函数和友元 (protected 类或) 类或函数使用。 此外，它们还可由派生自该类的类使用。
`public`: 声明为 的 public 类成员可用于任何函数。

![](/post/images/20211116/1.png)

struct默认访问权限是public，class默认访问权限是private。  

## 4.5 友元  
类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数成为它的友元(friend)。友元不是函数成员。

如果类想把一个函数作为它的友元，只需增加一条以friend关键字开始的函数声明语句即可。**友元声明只能出现在类定义的内部，但是位置可以不限** (private/public)。  

* 友元的声明仅指定了访问权限，而非通常意义的函数声明，所以在使用某个友元函数时还需要额外进行函数声明，所以友元的声明和类本身放置在同一个头文件中。
* 重载函数声明为友元必须每个都声明一遍。

定义友元类和函数：  
```C++  
class A{
    friend int getTotal(){xxx}; // 函数可以访问该类的私有属性
    friend class Window_mgr;        // 类可以访问该类的私有属性 

    // 下面是将成员函数声明为友元
    friend void ::Window_mgr::clear(ScreenIndex){..}
}
```  

友元声明仅代表权限，调用时还需要在函数外声明友元函数（不加friend）。



## 4.6 mutable 关键字  
mutable声明的成员变量可以在被const修饰的成员函数内修改，也可以在声明为const对象上被修改，例如：  
```C++  
class Screen{
public:
    public void sime_member() const;

private: mutable size_t access_ctr;     // 即使是在const对象上也能被修改  
};

void Screen::some_member() const {
    ++access_ctr;
}

const Screen s;
s.access_ctr++;
```  

## 4.7 变量名查找过程  
* 首先在成员函数内查找该名字
* 在类内继续查找该相同名字的成员变量
* 在成员函数定义之前和类定义之前距的作用域内查找变量名

## 4.8 隐式类型转换  
能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。  

只允许一步类类型转换，也就是说c_str -> string -> other_class中，允许other_class c = string，而不允许other_class c = "xxx";  

关键字explicit能够阻止隐式转换，例如：  
```C++  
class Sales_data{

    explicit Sales_data(std::istream &);        // 不允许隐式转换
}
```  

## 4.8 静态成员  
加上`static`关键字。类名::静态成员名。



# 5-泛型编程  
标准库提供了algorithm库和neumeric库，比如find、count，只接受迭代器而不接受具体类型，因此泛型不调用任何容器，而只调用迭代器。

## 5.1 消除重复的单词，sort+unique+erase
```C++  
void elimDups(vector<string> & words) {
    // 按字典排序，以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域之后的一个位置的迭代器
    // 之后的位置存放什么是未知的
    auto end_unique = unique(words.begin(), words.end());

    // 使用向量操作erase删除重复单词
    words.erase(end_unique, words.end());
}
```

## 5.2 sort中定制比较函数  
sort 默认使用`<`运算符，但是sort还接受一个比较函数：  
```C++  
bool isShorter(const string & s1, const string & s2) {
    return s1.size() < s2.size();
}
```  
sort也可以使用stable_sort。  

## 5.3 Lambda表达式  
可调用对象包括函数和函数指针，还包括重载了函数调用运算符的类和Lambda表达式。  
格式：  
```C++  
[capture_list](parameter_list) -> return type {function body}
```  
* capture_list是一个lambda所在函数中定义的局部变量的列表，通常为空。
* parameter_list表示参数列表
* return type表示返回类型，lambda函数必须使用尾置返回值
* function body表示函数体。  
例如：  
```C++
auto f = []{return 42;}
```  

稳定排序自定义关键字：  
```C++  
stable_sort(words.begin(), words.end(),
    [](const string & a, const string & b){return a.size() < b.size();});
```  

虽然一个lambda可以出现在某一个函数中并且可以使用这个函数的局部变量，但是它只能使用那些明确指明的变量，在捕获列表中指出来。  
```C++  
[sz](const string & a){return a.size() >= sz;}
```  

**forEach算法**： 算法标准库提供了forEach算法，`for_each(words.begin(), words.begin(), [](const string &){cout<<s<<" ";})`  

lambda实际上是一个函数对象，也就是说当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。  

值捕获：变量的捕获方式也可以分为值或引用。例如：  
```C++  
void fcn1(){
    size_t v1 = 42; 
    auto f = [v1]{return v1};       // 值捕获
    auto f2 = [&v1]{return v1};     // 引用捕获
}
```  
引用捕获应当捕获一个存在的对象，所以返回一个lambda表达式时必须保证捕获列表中不存在局部变量。  

**隐式捕获**：可以让编译器自动推断捕获的变量，\=表示值捕获，&表示引用捕获，例如：  
```C++  
// 值捕获
wc = find_if(words.begin(), words.end(), 
        [=](const string & s){return s.size() >= sz});
```  

**lambda表达式指定返回值**：如果只有一个return，则编译器能够推断出返回值类型，如果有超过一个返回值并且没有指定返回值类型，则默认返回值为void。  

**标准库bind函数**：
bind函数传入一个Callable，返回一个Callable，相当于Python装饰器，语法格式：  
```C++  
auto newCallable = bind(callable, arg_list);
```  
arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：\_1为newCallable的第一个参数，\_2为第二个参数，以此类推。  

首先将参数传递给newCallable中，newCallable将传进来的参数按照_n和arg_list传递到callable中。

假设check_size函数需要两个参数string 和 int才能调用，我们向包装一下生成一个check6函数，让int参数固定为6，这样直接调用check6(string)就可以，那么实现如下：  
```C++  
auto check6 = bind(check_size, _1, 6);

// 相当于
check_size(string, 6)，其中_1表示string s参数被保留
```   
例二：  
假设f接受5个参数，g接受两个参数，则：
```C++  
auto g = bind(f, a, b, _2, c, _1);
```  
调用g(x, y)相当于调用f(a, b, y, c, x);
> _n参数定义在std::placeholders空间中，需要声明才可以使用，例如using namespace std::placeholders或者using std::placeholders::_1  

**绑定引用参数**：  
```C++
forEach(words.begin(), words.end(), bind(print, ref(os), _1, ' '));  
```  
注意：ref是functional标准库定义的引用绑定方法，还有一个cref是常量引用。  

# 6-动态内存  
## 6.1 智能指针  
原来管理动态内存需要new 和 delete。  
```C++  
double * d = new double;
delete d;

char * ch = new char[20];
delete[] ch;

Class * c = new Class();
delete c;
```  

memory标准库提供了智能指针，shared_ptr允许多个指针指向同一个对象；unique_ptr独占所指的对象，weak_ptr是弱引用，指向shared_ptr所管理的对象。  

**shared_ptr类**  

```C++
shared_ptr<string> p1;
shared_ptr<list<int> > p2;

// 如果p1不为空指针并且p1指向的字符串不为空，则改变这个字符串
if(p1 != nullptr && p1->empty()){
    *p1 = "hi";
}
```  
shared_ptr和unique_ptr支持的操作：  
|函数方法|说明|
|:----:|:----:|
|shared_ptr\<T\>|空智能指针|
|p|将p用作一个条件判断，若p指向一个对象，则为true|
|*p|解引用p，获得它所指向的对象|
|p->mem|等价于(*p).mem|
|p.get()|返回p中所保存的指针，但是如果智能指针释放了该对象，则其返回的可能是野指针|
|p.swap(q)|交换p和q中的指针|

share_ptr独有的操作
|函数方法|说明|
|:---:|:----:|
|make_shared\<T\>(args)|返回一个shared_ptr，指向一个动态分配类型为T的对象|
|p = q|p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放|
|p.unique()|若p.use_count()为1，则返回true，否则返回false|
|p.use_count()|返回与p共享对象的智能指针数量；可能很慢，用于调试|

最安全的创建智能指针的方式是make_shared函数，例如：  
```C++  
shared_ptr<int> p3 = make_shared<int>(3);
// 生成一个字符串为"9999999999"的字符串并指向它的指针
shared_ptr<string> p4 = make_shared<string>(10, '9');
```  
和emplace类似，make_shared函数的参数也是构造函数相应的参数，实现方法可以是bind函数（参见之前）。  

**引用递增**：  
无论何时，当进行拷贝和赋值操作时，都有一个计数器会递增引用，或者函数传参时，引用数都会递增。当shared_ptr被赋予一个新值或者shared_ptr被销毁时，例如局部shared_ptr离开作用域，计数器就会递减。一旦shared_prt计数器变为0，他就会自动释放自己所管理的对象。  

## 自动释放内存的实现  
首先，当对象离开作用域之前，也就是在`}`处，C++编译器会自动补上析构函数（可能是一段汇编跳转指令，也可能是预处理时就补上了）。

那么当调用shared_ptr\<T\>时，智能指针自动析构，引用计数减一，如果此时引用计数为0，则自动释放其内存。  

## new 和 delete
new会调用构造函数，delete会调用析构函数。所以使用智能指针的方法管理对象，能够自动析构。典型的两个例子：  
1. 函数分配空间之后的代码里，抛出异常且没有捕获，如果没有智能指针则内存永远无法被释放。而智能指针能够在函数出口处让引用计数-1，此时有可能会自动 delete
2. 智能指针会自动析构，那么可以在析构函数里调用close等关闭连接的函数


**shared_ptr与new结合使用**  
```C++  
shared_ptr<double> p1(new int(42));     // 正确
shared_ptr<double> p2 = new int(42);    // 错误，不能使用赋值初始化
```  
* 不能混合使用普通指针和智能指针。
* 不能使用get为指针进行赋值
* 不使用相同的内置指针初始化多个智能指针

shared_ptr还能够使用reset方法将一个新的指针赋予一个shared_ptr；

如果智能指针传递进去的不是new出来的指针，那么结束后应当传入一个delete函数，智能指针会自动调用delete函数而不是delete关键字，这用于网络/文件的连接关闭操作：  
```C++  
void f(destination & d){
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    // 使用连接

    // 当f退出时（即使是异常退出），connection会被正确关闭，因为他调用end_connection，而不是delete p；
}
```  

## unique_ptr  
某一时刻unique_ptr只能指向一个给定的对象。构造方法没有make_shared库函数，只能用**直接**初始化方法，将其绑定到一个new返回的指针：`unique_ptr<double> p2(new int(42))`，unique_ptr不支持赋值。

|操作名称|说明|
|:----:|:----:|
|unique_ptr\<T\> u1|空unique_ptr，可以指向类型为T的对象|
|unique_ptr\<T\, D> u2(d)|u2会使用一个类型为D的可调用对象来释放它的空指针|
|u = nullptr|释放u指向的对象，将u置为空|
|u.release()|u放弃对指向的控制权，返回指针，将u置空|
|u.reset()|释放u指向的对象|
|u.reset(q)|如果提供了内置指针q，令u指向这个对象；否则将u置空|

* 不能拷贝unique_ptr\<int\>
* 但是有一个例外就是可以作为函数返回一个unique_ptr  

## weak_ptr  
weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个由shared_ptr管理的对象。讲一个weak_ptr绑定到一个shared_ptr不会改变**引用计数**。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使weak_ptr还有指向，也依旧会被释放。
```C++  
weak_ptr<T>
weak_ptr<T> w(shared_ptr)   // 用shared_ptr初始化
w = p
w.reset()
w.use_count()       // 与w共享对象的shared_weak_ptr数量
w.expired()         // 若use_count()为0，返回true()
w.lock()            // 如果expired为true，返回一个空的shared_ptr，否则返回一个指向w的对象的shared_ptr
```  

访问对象前必须要先判断：  
```C++  
if(shared_ptr<int> np = wp.lock()){
    // 在if中，np与p共享对象
}
```










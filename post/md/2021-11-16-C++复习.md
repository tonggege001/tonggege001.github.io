---
layout: post  
title: 2021-11-16-C++复习
date: 2021-11-16
categories: blog
tags: [C++,编程语言]
description: C++复习
---  

# 2-变量和基本类型

## 2.1 const 关键字  
1. 在全局变量里定义 const 关键字，默认的作用域是本文件；在全局变量里定义非const变量，默认的作用域是整个程序。如果要让const常量作用在整个程序，则需要额外指定extern，例如 `extern const bufSize = 512;`  

2. 如果没有对常量的内存进行引用、指针操作，则它在编译前的预处理阶段就会替换原来的常量为字面量。如果进行了引用、地址操作，则会强行让编译器为其分配内存。

**顶层const**：表示指针本身是个常量。  
**底层const**：指针所指的对象是一个常量。  

```C++  
int * const p1 = &i;        // 这是一个顶层const，不能改变p1的值  
const int ci = 42;          // 这是个顶层const，不能改变ci的值
const int * p2 = &c1;       // 允许改变p2的值，这是一个底层const
const int *  const p3 = p2; // 右边的const是顶层const，左边const是底层const
const & r = ci;             // 用于声明引用的const都是底层const，因为引用本身就不能更改，天然带有顶层const属性
```  

auto会忽略顶层const，而只会保留底层const。  

**decltype**标识符：获得数值的类型。例子：  

```C++
decltype(f()) sum = x;  // 定义sum变量，类型是f的返回值类型，decltype并不调用f，编译期间就能够知道
const int ci = 0;
decltype(ci) x = 0;
decltype((ci)) x = 0;       // 获得的是引用类型，而不是原来的值类型，int&，而不是int
```

## 2.2 引用  
引用也就是变量的别名，主要用作函数的形式参数。

* const 引用是指向const对象的引用。

## 2.3 头文件  
头文件一般包含类的定义、extern变量的声明和函数声明，头文件的内容会被预处理器复制到程序对应的位置。一般要设置头文件保护符，目的是防止多次引用时同一文件下有多重定义：  
```C++  
#ifndef XXX
#define XXX
// 头文件内容  
#endif
```

头文件一般用作声明而不是定义：  
```C++  
extern int ival = 10;           // 有初始化，所以是定义。默认情况下extern可以省略
double fica_rate;               // 没有extern关键字，所以是定义
```

## 2.4 using 声明  
1. using 声明 (using declaration) 是将命名空间中单个名字注入到**当前作用域**的机制，使得在当前作用域下访问另一个作用域下的成员时无需使用限定符 ::  
```C++  
// OK
{
    using std::map
    map<int, std::string> the_map;
}
// ERROR
map<int, std::string> the_map2;
```
using 声明每次只能作用于一个命名空间成员，使用using声明后就不需要在名称前加std::这样的名称空间来。 
当然为了使用所有std或者其他名称空间的内容，你也可以直接using namespace std;

2. using 声明，可以改变派生类对父类成员的访问控制  

```C++  
class Base{
protected:
    int bn1;
    int bn2;
};
 
class Derived: private Base{
public:
    using Base::bn1;
};
 
class DerivedAgain: public Derived{
};
 
int main(){
    Derived d;
    DerivedAgain da; 
    d.bn1 = 1;
    d.bn2 = 2; //error, 'bn2' is a private member of 'Base'
    da.bn1 = 3;  //ok
    std::cout<<d.bn1<<std::endl;
 
    return 0;
}
```  
尽管 Derived 对 base 是私有继承，但通过 using 声明，我们还是可以在 Derived 中访问其成员，且后续的继承同样不受 private 限定的影响。  

3. 使一个命名空间中的 **所有** 名字都在该作用域中可见的机制。这是最常用的方式了。需要注意的是命名冲突问题。  
```C++
#include <iostream>
namespace n1{ 
    int n1_member = 10; 
    int m = 11; 
}
 
int m = 12; 
 
int main(){
    using namespace n1; 
    std::cout<<n1_member<<std::endl;
    //std::cout<<m<<std::endl;  //error 命名冲突
    std::cout<<::m<<std::endl;
 
    int m = 13; //ok, 局部变量屏蔽命名空间变量
    std::cout<<m<<std::endl;
 
    return 0;
}
```
尽管 using指示很方便，但在实际工作中应该尽量避免：它一下子将另一个 namespace 中的成员全部引入了，一不小心就会出现命名空间污染问题。  

4. 类型重定义，取代 typedef `using alias = typename`
```C++
using fun = void (*)(int, int);
//typedef void (*fun)(int, int); //与上一句等价
using int16 = short;
//typedef short int16; //与上一句等价
 
int main(){
    std::cout<<sizeof(int16)<<std::endl;
}
```  
为什么要类型重定义呢？原因是：  
在 C++98/03 中 ，typedef 重定义有一些限制，比如，模板。我们想实现这样一个模板：将一个 int 映射到任意类型，类似于我们想表达这种效果：  
```C++  
typedef std::map<int, int> map_int_t;
typedef std::map<int, std::string> map_str_t;
typedef std::map<int, bool> map_b_t;
//... Others
```  
但是在C++ 98中使用模板必须要这样写：  
```C++
template<typename Val>
struct int_map{
    typedef std::map<int, Val> type;
};
 
int main(){
    int_map<int>::type imap;
 
    return 0;
}
```  
在C++11 中，我们可以使用 using 重定义模板：  
```C++  
template<typename Val>
using int_map_t = std::map<int, Val>;
 
int main(){
    int_map_t<int> imap;
 
    return 0;
}
```  

## 2.5 运算符优先级  

1. `[]` `()` `.` `->`
2. `-` `(type)` `++` `--` `*` `&` `!` `~` `sizeof`
3. `/` `*` `%`
4. `+` `-`
5. `<<` `>>`
6. `>` `>=` `<` `<=`
7. `==` `!=` 
8. `&`
9. `^`
10. `|`
11. `&&`
12. `||`
13. `?:`
14. `=` `/=` `+=` ... `|=`
15. `,`  

## 2.6 指针+1
```C++  
int a;
int * p = &a;
int * q = p + 1;
```  
上面的代码如果p和q转换成int类型，那么可能q比p小4，这是因为栈空间是高地址向低地址增长，p是高地址，p+1代表地址增加一个最小单元，那么p+1一定在低地址，32位系统则可能差四个字节。  

```C++  
int a[3][4];
int (* p)[4] = a;
p = p+1;
```  
上面代码指针+1，地址加（或减，取决于栈空间还是堆）了sizeof(int) * 4。  

## 2.7 类型转换  
C++有隐式类型转换和或提升，也有显式类型转换。 一般int 

自动隐式转换，C在以下四种情况下会进行隐式转换:    
1、算术运算式中，低类型能够转换为高类型。
2、赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。
3、函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。
4、函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。  

优先级：  
char, short -> int -> unsigned -> long -> double;  
float -> double;  

所以当表达式中无符号数和有符号数都被转换为无符号数。

**显示转换**：  
`cast-name<type>(expression)`  

一共有四种类型 ：`static_cast`、`const_cast`、`const_cast`、`reinterpret_cast`  

`static_cast`：任何具有明确定义的类型转换，只要不包含底层const，都可以使用。  

`const_cast`：只能改变const变量的类型：  
```C++  
const char * pc;
char * p = const_cast<char *>(pc)
```  

`reinterpret_cast`：改变指针类型。  
```C++  
int * ip;
char * pc = reinterpret_cast<char *>(ip);
```  

## 2.8 else的就近原则  
if-else 嵌套，else对应的就近原则。  

## 2.9 switch-case内部定义变量  

switch-case中，case内部定义变量不能放在同一层，必须用{}括起来： 
```C++  
case true: {
    string filename;
    int ival = 10;
    int jval;
}
```  
下面的是错误代码，会导致隐式跳过变量的初始化。
```C++  
// 错误代码
case true: 
    string filename;
    int ival = 0;
    int jval;
case false;
    jval = 10;
```  

## 2.10 try-catch异常 
```C++ 
try {
    // 执行添加两个Sales_item  
    // 如果添加失败，代码抛出一个runtime_error异常
}catch(runtime_error err){
    cout<<err.what() <<"Try again Enter y or n"<<endl;
    char c;
    cin >> c;
    if(!cin || c== 'n'){
        break;
    }
}

```
注意：C++没有try-catch-finally，只有try-catch。当有异常发生时，中断当前程序，然后搜索当前是否有error，没有则沿着函数调用链反方向抛出。当都没有找到对应的error，则程序被转为terminate的标准库函数，该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。  

标准库函数提供的部分异常：  
|异常名称|描述|  
|:----:|:----:|  
|exception|最常见问题|
|runtime_error|只有运行时才能检测出问题|
|range_error|运行时的值超出范围|
|overflow_error|计算上溢|
|underflow_error|计算下溢|
|...|...|  

异常类型只返回一个what()的成员函数，该函数没有任何参数，返回一个C风格字符串。  

# 3-函数  

## 3.1 函数传参  
* 当const实参传递给形参时，顶层const被忽略。
* 当不改变参数时，尽量用常量引用，const string &  

**含有可变参数的函数**  
参数一样的时候，可以使用initializer_list：  
```C++  
void error_msg(initializer_list<string> li){
    for(auto beg = li.begin();beg != li.end();beg++){
        cout<<*beg<<endl;
    }
}  

// 调用：  
error_msg({"hello", "world", "!"});  
```  

为了兼容C，则可以用`...`作为省略形参，然后再通过C库varargs变量获得。  

## 3.2 函数返回值和引用  
返回值时，比如string。那么意味着返回值会被拷贝到调用点，因此函数会返回一个副本或者未命名的临时变量。  

如果返回引用，则不会拷贝，例如：  
```C++  
const string & shorterStr(const string & s1, const string & s2){
    return s1.size() <= s2.size()?s1:s2;
}
```

**注意：不要返回局部对象的引用**  
```C++  
// 错误的例子
const string & manip(){
    string ret;
    ...
    return ret;
}
```

## 3.3 函数重载  
函数名相同，形参不同的函数。  
> 形参会忽略顶层const，所以有无顶层const不能区分不同函数。  

```C++  
Record lookup(Phone *);
Record lookup(Phone * const);       // 重复声明！  

Record lookup(Account &);
Record lookup(const Account &);     // 新函数

Record lookup(Account *);
Record lookup(const Account *);     // 新函数
```  

重载函数的匹配：首先选择候选函数，然后选择不需要强制类型转换的最佳匹配，如果都是最佳匹配则报二义性错误。

类的成员函数按照是否是const也可以重载：  
```C++  
Screen & display(std::ostream & os){xxx};
Screen & display(std::ostream & os) const {xxx};    // 正确，可以重载，函数选择会根据调用对象是否是const来选择。
```

**重载与作用域**  
作用域内的函数声明会屏蔽掉作用域外的的重载函数，比如：  
```C++  
void print(const string &);
void print(double);

void fooBar(int val){
    void print(int);        // 新作用域屏蔽了前面两个print

    print("hello");         // ERROR
    print(3);               // 正确  
    print(3.14)；           // 正确，实际调用的是print(int)
}
```  



## 3.4 默认实参  
`string screen(int name, size_type ht=24, size_type wid=80);`  

## 3.5 内联函数  
内联函数就是将它在调用点内联地展开。在函数的返回值前面加上inline即可声明。当然，编译器也可以忽略这个内联的请求。  

## 3.6 调试帮助  
`assert`宏使用：`assert(expr)`，首先对表达式expr进行求值，如果表达式为假则assert输出信息并终止程序执行，如果表达式为真，assert什么都不做。预处理assert宏在cassert头文件中。  

assert行为依赖于NDBUG预处理变量，若定义了NDEBUG，则assert什么也不做。  

NDEBUG还可以用于自己定义变量：  
```C++  
void print(const int ia[], size_t, size){
    #ifndef NDBUG
        // __func__是编译器定义的一个局部静态变量，用于存放函数的名字  
        cerr<< __func__<<": array size is "<<size<<endl;
    #endif
}
```
当然，C++预处理器还定义了以下几个字符串字面值：  
\_\_FILE\_\_: 存放文件名的字符串字面值  
\_\_LINE\_\_: 存放当前行号的整型字面值  
\_\_TIME\_\_: 存放文件编译的时间的字符串字面值
\_\_DATE\_\_: 存放文件编译日期的字符串字面值

## 3.7 函数指针  
指向函数的指针:  
```C++  
bool (*pf)(const string &, const string &);
pf = lengthCompare;
pf = &lengthCompare;        // 上面两者等价，取地址符是可选的
```  

调用函数也可以不用解引用，直接调用`pf(xxx,xxx);`  

当pf=nullptr或者pf=0时，表示该指针没有指向任何一个函数。  

**函数指针作为形参和返回值**  
使用using或者typedef起别名。  

```C++  
typedef decltype(lengthCompare) Func2;

using PF = int(*)(int *, int *);
PF f1(int){
    .....
}

// 等价于  
int (*f1(int))(int *, int *);  

// 使用尾置返回值类型：  
auto f1(int) -> int(*)(int *, int);
```  

# 4-类  
## 4.1 this  
成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用`total.isbn()`，则编译器负责把total的地址给isbn的隐式形参this，可以等价地认为编译器将调用重写成`Sales_data::isbn(&total);`。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符做到这一点，比如this->bookNo简化成bookNo  

**成员函数参数列表后面的const**：修改隐式this的类型为底层const  

## 4.2 成员函数  
我们定义成员函数是在类的外部定义：  
```C++  
double Sale_data::avg_price() const {
    ...
}
```  

**定义一个返回this对象的函数**：注意，返回值必须是左值，所以是返回引用。  
```C++  
Sales_data & Sales_data::combine(const Sales_data & rhs){
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```  

## 4.3 构造函数  
如果没有构造函数，则编译器创建一个默认构造函数。初始化成员：  
* 如果存在类内的初始值，用它来初始化成员
* 否则默认初始化该成员，对象成员没初始化，其值由类决定（栈空间则随机，堆空间则为0）

如果我们定义了构造函数，则编译器不会定义默认构造函数，就需要自己再定义默认构造函数了。  

自动定义默认构造函数：  
```C++  
struct Sales_data{
    Sales_data() = default;
    Sales_data(const std::string &s):bookNo(s){...}  
    Sales_data(std::istream &);         // 定义在类外面，不包含函数体
}
```  

**委托构造函数：** 受委托的函数执行完毕后，接着执行自己的构造函数  
```C++  
class Sales_data {
public: 
// 非委托构造函数使用对应的实参初始化成员
Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt * price){};

// 其余构造函数全部委托给另一个构造函数
Sales_data():Sales_data("", 0, 0){}
Sales_data(std::string s): Sales_data(s, 0, 0){}
Sales_data(stdingLListream & is):Sales_data(){read(is, *this)};
}
```

## 4.4 访问控制与封装  

`private`: 类成员只能由成员函数和友元 (private 类或类) 的友元使用。
`protected`: 类成员可以由成员函数和友元 (protected 类或) 类或函数使用。 此外，它们还可由派生自该类的类使用。
`public`: 声明为 的 public 类成员可用于任何函数。

![](/post/images/20211116/1.png)

struct默认访问权限是public，class默认访问权限是private。  

## 4.5 友元  
类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数成为它的友元(friend)。友元不是函数成员。

如果类想把一个函数作为它的友元，只需增加一条以friend关键字开始的函数声明语句即可。**友元声明只能出现在类定义的内部，但是位置可以不限** (private/public)。  

* 友元的声明仅指定了访问权限，而非通常意义的函数声明，所以在使用某个友元函数时还需要额外进行函数声明，所以友元的声明和类本身放置在同一个头文件中。
* 重载函数声明为友元必须每个都声明一遍。

定义友元类和函数：  
```C++  
class A{
    friend int getTotal(){xxx}; // 函数可以访问该类的私有属性
    friend class Window_mgr;        // 类可以访问该类的私有属性 

    // 下面是将成员函数声明为友元
    friend void ::Window_mgr::clear(ScreenIndex){..}
}
```  

友元声明仅代表权限，调用时还需要在函数外声明友元函数（不加friend）。



## 4.6 mutable 关键字  
mutable声明的成员变量可以在被const修饰的成员函数内修改，也可以在声明为const对象上被修改，例如：  
```C++  
class Screen{
public:
    public void sime_member() const;

private: mutable size_t access_ctr;     // 即使是在const对象上也能被修改  
};

void Screen::some_member() const {
    ++access_ctr;
}

const Screen s;
s.access_ctr++;
```  

## 4.7 变量名查找过程  
* 首先在成员函数内查找该名字
* 在类内继续查找该相同名字的成员变量
* 在成员函数定义之前和类定义之前距的作用域内查找变量名

## 4.8 隐式类型转换  
能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。  

只允许一步类类型转换，也就是说c_str -> string -> other_class中，允许other_class c = string，而不允许other_class c = "xxx";  

关键字explicit能够阻止隐式转换，例如：  
```C++  
class Sales_data{

    explicit Sales_data(std::istream &);        // 不允许隐式转换
}
```  

## 4.8 静态成员  
加上`static`关键字。类名::静态成员名。



# 5-泛型编程  
标准库提供了algorithm库和neumeric库，比如find、count，只接受迭代器而不接受具体类型，因此泛型不调用任何容器，而只调用迭代器。

## 5.1 消除重复的单词，sort+unique+erase
```C++  
void elimDups(vector<string> & words) {
    // 按字典排序，以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域之后的一个位置的迭代器
    // 之后的位置存放什么是未知的
    auto end_unique = unique(words.begin(), words.end());

    // 使用向量操作erase删除重复单词
    words.erase(end_unique, words.end());
}
```

## 5.2 sort中定制比较函数  
sort 默认使用`<`运算符，但是sort还接受一个比较函数：  
```C++  
bool isShorter(const string & s1, const string & s2) {
    return s1.size() < s2.size();
}
```  
sort也可以使用stable_sort。  

## 5.3 Lambda表达式  
可调用对象包括函数和函数指针，还包括重载了函数调用运算符的类和Lambda表达式。  
格式：  
```C++  
[capture_list](parameter_list) -> return type {function body}
```  
* capture_list是一个lambda所在函数中定义的局部变量的列表，通常为空。
* parameter_list表示参数列表
* return type表示返回类型，lambda函数必须使用尾置返回值
* function body表示函数体。  
例如：  
```C++
auto f = []{return 42;}
```  

稳定排序自定义关键字：  
```C++  
stable_sort(words.begin(), words.end(),
    [](const string & a, const string & b){return a.size() < b.size();});
```  

虽然一个lambda可以出现在某一个函数中并且可以使用这个函数的局部变量，但是它只能使用那些明确指明的变量，在捕获列表中指出来。  
```C++  
[sz](const string & a){return a.size() >= sz;}
```  

**forEach算法**： 算法标准库提供了forEach算法，`for_each(words.begin(), words.begin(), [](const string &){cout<<s<<" ";})`  

lambda实际上是一个函数对象，也就是说当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。  

值捕获：变量的捕获方式也可以分为值或引用。例如：  
```C++  
void fcn1(){
    size_t v1 = 42; 
    auto f = [v1]{return v1};       // 值捕获
    auto f2 = [&v1]{return v1};     // 引用捕获
}
```  
引用捕获应当捕获一个存在的对象，所以返回一个lambda表达式时必须保证捕获列表中不存在局部变量。  

**隐式捕获**：可以让编译器自动推断捕获的变量，\=表示值捕获，&表示引用捕获，例如：  
```C++  
// 值捕获
wc = find_if(words.begin(), words.end(), 
        [=](const string & s){return s.size() >= sz});
```  

**lambda表达式指定返回值**：如果只有一个return，则编译器能够推断出返回值类型，如果有超过一个返回值并且没有指定返回值类型，则默认返回值为void。  

**标准库bind函数**：
bind函数传入一个Callable，返回一个Callable，相当于Python装饰器，语法格式：  
```C++  
auto newCallable = bind(callable, arg_list);
```  
arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：\_1为newCallable的第一个参数，\_2为第二个参数，以此类推。  

首先将参数传递给newCallable中，newCallable将传进来的参数按照_n和arg_list传递到callable中。

假设check_size函数需要两个参数string 和 int才能调用，我们向包装一下生成一个check6函数，让int参数固定为6，这样直接调用check6(string)就可以，那么实现如下：  
```C++  
auto check6 = bind(check_size, _1, 6);

// 相当于
check_size(string, 6)，其中_1表示string s参数被保留
```   
例二：  
假设f接受5个参数，g接受两个参数，则：
```C++  
auto g = bind(f, a, b, _2, c, _1);
```  
调用g(x, y)相当于调用f(a, b, y, c, x);
> _n参数定义在std::placeholders空间中，需要声明才可以使用，例如using namespace std::placeholders或者using std::placeholders::_1  

**绑定引用参数**：  
```C++
forEach(words.begin(), words.end(), bind(print, ref(os), _1, ' '));  
```  
注意：ref是functional标准库定义的引用绑定方法，还有一个cref是常量引用。  

# 6-动态内存  
## 6.1 智能指针  
原来管理动态内存需要new 和 delete。  
```C++  
double * d = new double;
delete d;

char * ch = new char[20];
delete[] ch;

Class * c = new Class();
delete c;
```  

memory标准库提供了智能指针，shared_ptr允许多个指针指向同一个对象；unique_ptr独占所指的对象，weak_ptr是弱引用，指向shared_ptr所管理的对象。  

**shared_ptr类**  

```C++
shared_ptr<string> p1;
shared_ptr<list<int> > p2;

// 如果p1不为空指针并且p1指向的字符串不为空，则改变这个字符串
if(p1 != nullptr && p1->empty()){
    *p1 = "hi";
}
```  
shared_ptr和unique_ptr支持的操作：  
|函数方法|说明|
|:----:|:----:|
|shared_ptr\<T\>|空智能指针|
|p|将p用作一个条件判断，若p指向一个对象，则为true|
|*p|解引用p，获得它所指向的对象|
|p->mem|等价于(*p).mem|
|p.get()|返回p中所保存的指针，但是如果智能指针释放了该对象，则其返回的可能是野指针|
|p.swap(q)|交换p和q中的指针|

share_ptr独有的操作
|函数方法|说明|
|:---:|:----:|
|make_shared\<T\>(args)|返回一个shared_ptr，指向一个动态分配类型为T的对象|
|p = q|p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放|
|p.unique()|若p.use_count()为1，则返回true，否则返回false|
|p.use_count()|返回与p共享对象的智能指针数量；可能很慢，用于调试|

最安全的创建智能指针的方式是make_shared函数，例如：  
```C++  
shared_ptr<int> p3 = make_shared<int>(3);
// 生成一个字符串为"9999999999"的字符串并指向它的指针
shared_ptr<string> p4 = make_shared<string>(10, '9');
```  
和emplace类似，make_shared函数的参数也是构造函数相应的参数，实现方法可以是bind函数（参见之前）。  

**引用递增**：  
无论何时，当进行拷贝和赋值操作时，都有一个计数器会递增引用，或者函数传参时，引用数都会递增。当shared_ptr被赋予一个新值或者shared_ptr被销毁时，例如局部shared_ptr离开作用域，计数器就会递减。一旦shared_prt计数器变为0，他就会自动释放自己所管理的对象。  

## 自动释放内存的实现  
首先，当对象离开作用域之前，也就是在`}`处，C++编译器会自动补上析构函数（可能是一段汇编跳转指令，也可能是预处理时就补上了）。

那么当调用shared_ptr\<T\>时，智能指针自动析构，引用计数减一，如果此时引用计数为0，则自动释放其内存。  

## new 和 delete
new会调用构造函数，delete会调用析构函数。所以使用智能指针的方法管理对象，能够自动析构。典型的两个例子：  
1. 函数分配空间之后的代码里，抛出异常且没有捕获，如果没有智能指针则内存永远无法被释放。而智能指针能够在函数出口处让引用计数-1，此时有可能会自动 delete
2. 智能指针会自动析构，那么可以在析构函数里调用close等关闭连接的函数


**shared_ptr与new结合使用**  
```C++  
shared_ptr<double> p1(new int(42));     // 正确
shared_ptr<double> p2 = new int(42);    // 错误，不能使用赋值初始化
```  
* 不能混合使用普通指针和智能指针。
* 不能使用get为指针进行赋值
* 不使用相同的内置指针初始化多个智能指针

shared_ptr还能够使用reset方法将一个新的指针赋予一个shared_ptr；

如果智能指针传递进去的不是new出来的指针，那么结束后应当传入一个delete函数，智能指针会自动调用delete函数而不是delete关键字，这用于网络/文件的连接关闭操作：  
```C++  
void f(destination & d){
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    // 使用连接

    // 当f退出时（即使是异常退出），connection会被正确关闭，因为他调用end_connection，而不是delete p；
}
```  

## unique_ptr  
某一时刻unique_ptr只能指向一个给定的对象。构造方法没有make_shared库函数，只能用**直接**初始化方法，将其绑定到一个new返回的指针：`unique_ptr<double> p2(new int(42))`，unique_ptr不支持赋值。

|操作名称|说明|
|:----:|:----:|
|unique_ptr\<T\> u1|空unique_ptr，可以指向类型为T的对象|
|unique_ptr\<T\, D> u2(d)|u2会使用一个类型为D的可调用对象来释放它的空指针|
|u = nullptr|释放u指向的对象，将u置为空|
|u.release()|u放弃对指向的控制权，返回指针，将u置空|
|u.reset()|释放u指向的对象|
|u.reset(q)|如果提供了内置指针q，令u指向这个对象；否则将u置空|

* 不能拷贝unique_ptr\<int\>
* 但是有一个例外就是可以作为函数返回一个unique_ptr  

## weak_ptr  
weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个由shared_ptr管理的对象。讲一个weak_ptr绑定到一个shared_ptr不会改变**引用计数**。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使weak_ptr还有指向，也依旧会被释放。
```C++  
weak_ptr<T>
weak_ptr<T> w(shared_ptr)   // 用shared_ptr初始化
w = p
w.reset()
w.use_count()       // 与w共享对象的shared_weak_ptr数量
w.expired()         // 若use_count()为0，返回true()
w.lock()            // 如果expired为true，返回一个空的shared_ptr，否则返回一个指向w的对象的shared_ptr
```  

访问对象前必须要先判断：  
```C++  
if(shared_ptr<int> np = wp.lock()){
    // 在if中，np与p共享对象
}
```  

## allocator 类  
new 会将内存分配和对象构造合并在一起，delete会将内存释放和对象析构合并在一起。allocator类定义在头文件memory，它帮助我们将内存分配和对象构造分离开来。  

allocator分配的内存是原始的、未构造的。allocator需要传入一个模板，例如：  

```C++  
allocator<string> alloc;            // 可以分配string的allocator对象
auto const p = alloc.allocatr(n);   // 分配n和未初始化的string  
```  
方法：  
|方法|说明|
|:----:|:----:|
|allocator\<T\> a| 定义名为a的allocator对象，它可以为类型T的对象分配内存|
|a.allocator(n)|分配一段原始的、未构造的内存，保存n个类型为T的对象|
|a.deallocate(p, n)|释放从T *指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocator返回的指针，n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy|
|a.construct(p, args)|p必须是一个类型为T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象|
|a.destroy(p)|p为T*类型的指针，此算法对p指向的对象执行析构函数|  
用完对象必须销毁，例如：  
```C++  
while(q!= p)
    alloc.destroy(--q);
```  


# 7-拷贝控制  

## 7.1 拷贝构造函数  
构造函数的第一个参数是**自身引用类型**并且任何额外参数都有默认值，则为拷贝构造函数。例如：  
```C++  
class Foo {
    public:
    Foo();                  // 默认构造函数
    Foo(const Foo & );      // 拷贝构造函数
}
```
编译器默认会为我们提供一个拷贝构造函数，不管有没有定义其他构造函数都会提供。  

**拷贝初始化**：  
```C++
// 拷贝初始化
string s2 = dots;
string null_book = "9-999-999";  
string nines = string(100, '9');  

// 直接初始化：  
string s(dots);
string dots(10, '.');
```  
强行让编译器定义一个拷贝运算符：  
```C++  
class Sales_data {
public: 
    Sales_data() = default;
    Sales_data(const Sales_data & ) = default;
}
```

**拷贝运算符**：  
如果类没有定义拷贝运算符，编译器会合成一个拷贝运算符。合成的拷贝运算符就是将右边成员通过'='运算赋值过左边去。  

**析构函数**
成员初始化按照函数执行体前完成并按照它们在类中出现的顺序进行初始化；在析构函数中，首先执行函数体，然后销毁成员。成员的初始化顺序的逆序**销毁**。  

调用析构函数时机：  
* 变量离开作用域
* 当一个对象被销毁时，其成员被销毁
* 容器被销毁时，其元素被销毁
* delete运算时被销毁
* 对于临时对象，当创建完它的完整表达式结束时被销毁

## 7.2 三/五法则  

1. **需要析构函数的类也需要拷贝和赋值操作**  
解释：因为析构函数要释放一些资源，这些资源是类独占的（比如new 出来的成员），那么在拷贝和赋值过程中可能也要赋值一份新的资源来给新对象。如果不需要赋值新资源，理论上也不需要析构，因为资源并不是独占的。  

2. **需要拷贝操作的类也需要赋值**  
因为拷贝构造和赋值操作某种意义上也差不多。  


**阻止拷贝**  
```C++  
struct NoCopy {
    NoCopy() = default;
    NoCopy(const NoCopy & ) = delete;           // 阻止拷贝
    NoCopy &operator=(const NoCopy &) = delete; // 阻止赋值
}
```  
**析构函数不能是删除的成员，也就是不能被阻止**  

**合成的拷贝控制成员可能是删除的**  


Private定义的拷贝函数用户无法使用，但是友元却可以使用。所以需要private声明拷贝函数但不定义，这样友元和外部用户均无法使用，起到了阻止的作用。  

> 试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

## 7.3 reallocate 的使用，移动而不是拷贝  
```C++  
void StrVec::reallocate() {
    // 我们将分配当前大小两倍的内存空间  
    auto newcapacity = size() ? 2 * size():1;
    auto newdata = alloc.allocate(newcapacity);

    // 移动数据  
    auto dest = newdata;        // 指向数组中下一个空闲位置
    auto elem elements;         // 指向旧数组中下一个元素
    for(size_t i = 0;i<size();++i){
        alloc.construct(dest++, std::move(*elem++));
    }

    free();

    elements = new data;
    first_free = dest;
    cap = elements + newcapacity;
}
```  
注意，上面的std::move表示希望使用string的移动构造函数，如果漏掉了move则会使用拷贝构造函数。移动构造函数的效率高于拷贝构造函数。  

## 7.4 对象移动  
为了支持移动操作，新标准(C++11)引入了一种新的引用类型：**右值引用**。也就是绑定到右值的引用，使用&&表示而不是&。右值引用只能绑定到一个将要销毁的对象，因此可以自由的将一个右值引用资源移动到另一个对象中。  

```C++  
int i = 42;
int & i;            // 正确，r引用i
int && rr = i;      // 错误，不能将一个右值引用绑定到一个左值上
int & r2 = i * 42;  // 错误，i* 42是一个右值
const int & r3 = i * 42;    // 正确，可以将一个const的引用绑定到一个右值上
int && rr = i * 42; // 正确，将rr2绑定到乘法结果 
```  

左值有持久状态，右值只能绑定到临时对象（引用对象将要销毁、该对象没有其他用户）。**使用右值引用的代码可以自由接管所引用的对象的资源**。  

std::move函数将左值转化为右值。  

**移动构造函数**  
```C++  
StrVec::StrVec(StrVec && s) noexcept        // 移动操作不应抛出任何异常 
// 成员初始化器接管s中的资源
:elements(s.elements), first)free(s.first_free), cap(s.cap)
{
    // 令s 进入这样的状态，对其运行析构函数是安全的
    s.elements = s.fist_free = s.cap = nullptr;
}
```  
拷贝构造函数分配新内存，移动构造函数不分配新内存。  

**移动赋值运算符**  
```C++
StrVec & StrVec::operator=(StrVec && rhs) noexcept {
    // 直接检测自赋值  
    if(this != &rhs) {      
        free();                         // 释放已有元素
        elements = rhs.element;  
        first_free = rhs.first_free;    // rhs 接管资源  
        cap = rhs.cap;
        // 将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }

    return * this
}
```  
注意：**移动完毕后的源对象必须处于可析构状态，也就是将指针置为nullptr**。

当一个类没有任何自己版本的拷贝控制成员，且类的非static数据成员都可移动时，比那一起才会为它合成移动构造函数或移动赋值运算符。  

移动构造函数被定义删除的条件：  
* 有类成员**定义了自己的拷贝构造函数**且**未定义移动构造函数**
* 移动构造函数或移动赋值运算符被显式定义删除的
* 类的析构函数被定义为删除的或不可访问的
* 有类成员是const的，或是有类成员是引用

既有移动构造函数也有拷贝构造函数，则看传入的是左值还是右值。
没有定义移动构造函数但定义了拷贝构造函数，则出右值也会被拷贝。  

**移动迭代器**  
一个移动迭代器能够改变给定迭代器的解引用运算符(*)的行为来适配此迭代器。也就是说移动迭代器的解引用运算返回一个指向元素的右值引用。  

标准库的make_move_iterator将普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器。  

例子：  
```C++  
void StrVec::reallocate() {
    // 分配大小两倍于当前规模的内存空间  
    auto newcapacity = size()?2*size():1;
    auto first = alloc.allocate(newcapacity);

    // 移动元素(不初始化)  
    auto last = uninitialized_copy(make_move_iterator(begin()), 
                            make_move_iterator(end()), first);
    free();
    elements = fisrt;
    first_free = last;
}
```  
uninitialized_copy对输入序列中的每个元素调用construct来将元素“拷贝”到目的位置。此算法使用迭代器的**解引用运算符从输入序列中提取元素**。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着construct将使用移动构造函数来构造元素。  

## 普通成员函数的const &和右值引用  
普通成员函数的形参可以是const 的左值引用，也可以是&&的右值引用，通过二者的使用含义不同完成不同的函数体。const的左值引用一般要复制形参的内容（也就是开辟新内存保存内容），而右值引用参数的成员函数一般要“窃取”形参内容（也就是交换指针）。  

**向右值引用赋值**  
有时会出现`s1 + s2 = "wow!"`这样的代码，为了兼容性，编译器没有禁止这一行为，所以为了避免出现这种情况，在定义赋值函数时需要加一个引用限定符来确保只能向可修改的左值赋值：  
```C++  
class Foo {
public: 
    Foo & operator=(const Foo &) &;     // 只能向可修改的左值赋值
};

Foo & Foo::operator=(const Foo & rhs) & {
    // 执行将rhs赋予本对象所需的工作
    return *this;
}
```  
引用限定符可以是&或&&，分别**指出this可以指向一个左值或右值**。类似const限定符，引用限定符只能用于非static成员函数。  

**重载和引用函数**  
引用限定符也可以区分重载版本。（const）限定符也可以区分重载版本。


# 14-运算符重载  
重载的运算符是具有特殊名字的函数。二元运算符重载，第一个元素是左操作数，第二个元素是右操作数。出了重载的函数调用运算符operator()外，其他重载运算符不能还有默认实参。  

如果运算符的函数是成员函数，则它的第一个左侧运算对象绑定到隐式参数的this指针上。

可以直接调用或者间接调用：  
```C++  
data1 + data2;
operator+(data1, data2);  

data1 += data2;
data1.operator+(data1, data2);
```  

* 通常情况下，不应重载逗号，取地址，逻辑与，逻辑或 运算符。 

## 赋值运算符重载  
除了拷贝赋值运算符和移动赋值运算符，还可以把类的一个对象的值赋值给另一个对象，还可以把其他对象定义为赋值运算符的右侧：  

vector使用初始化列表进行赋值：  
```C++  
// 目标：  
vector<string> v;
v = {"a", "b", "c"};  

// 方法：  
class StrVec {
public: 
    StrVec & operator=(std::initializer_list<std::string> il){
        auto data = alloc_n_copy(il.begin(), il.end());
        free();
        elements = data.first;
        first_free = cap = data.second;
        return *this;
    }
}
```  

## 下标运算符
* 必须是成员函数。
* 下标运算符一般需要定义两个，一个返回常量引用，一个返回普通引用  

```C++  
class StrVec {
public:
    std::string & operator[](std::size_t n) {return elements[n];}

    const std::string & operator[](std::size_t n) const {
        return elements[n];
    }
private: 
    std::string * elements;
}
```  
当StrVec是常量时，调用第二个，否则调用第一个。  

## 递增递减运算符  
前置版本：  
```C++  
class StrBlobPtr{
public: 
    StrBlobPtr & operator++(){
        // check if end
        ++curr;
        return *this;
    };    
}
```  
后置版本，后置版本额外接受一个不被使用的int类型的实参：  
```C++  
class StrBlobPtr {
public: 
    StrBlobPtr operator++(int){     // 后置运算符 
        StrBlobPtr ret = *this;
        ++*this;
        return ret;
    };        
}
```  

## 函数调用运算符  
如果类重载了函数调用运算符，我们就可以像函数调用一样对对象实例进行调用。  
* 函数调用运算符只能是类的成员函数。  

```C++  
struct absInt {
    int operator()(int val) const {
        return val < 0?-val:val;
    }
};  

int i = -42;
absInt absObj;
int ui = absObj(i);
```  

lambda表达式实际上是一个函数对象。当我们编写一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中，含有一个重载的函数调用运算符，其形参和函数体与lambda表达式完全一样。  

**变量捕获**  
当lambda表达式通过**引用捕获**变量时，将由程序负责确保lambda执行时引用所引对象确实存在，因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。  

当lambda表达式通过**值捕获时**变量时，其产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。  

**标准库定义的函数对象**  
|算术|关系|逻辑|
|:----:|:----:|:----:|
|plus\<Type\>|equal_to\<Type\>|logical_and\<Type\>|
|minus\<Type\>|not_equal_to\<Type\>|logical_or\<Type\>|
|multiplies\<Type\>|**greater\<Type\>**|logical_not\<Type\>|
|divides\<Type\>|greater_equal\<Type\>||
|modules\<Type\>|**less\<Type\>**||
|negate\<Type\>|less_equal\<Type\>||


## 可调用函数与function  
C++中可调用对像包括：**函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类**。  

function类型：可调用对象的类型。例如：  

```C++  
function<int(int,int)> f1 = add;
function<int(int,int)> f2 = Divid();
function<int(int,int)> f3 = [](int i, int j){return i+j;};

// 那么可以构建一个map  
map<string, function<int(int, int)> > binops = {
    {"+", add},                                 // 函数指针
    {"-", std::minus<int>()},                   // 标准库对象
    {"/", divid()},                             // 用户自定义的函数对象
    {"*", [](int i, int j){return i*j;}},       // 未命名的lambda
    {"%", mod}                                  // 未命名的lambda对象
}

// 使用：  
binops["+"](10, 5);
```    

* function里面不能传入重载函数，必须使用函数指针或者lambda表达式包装下。

## 类型转换运算符  
```C++  
operator type() const;
```  
上面的类型转换允许隐式转换，为了避免这种情况，下面这种是显式转换：  
```C++  
class SmallInt{
public:
    explicit operator int() const{ return val;}
}
```  

显式转换在if, while, do、for, 逻辑运算符、条件运算符里还是会被隐式转换，所以在转换为bool时可以大胆用explicit关键字。









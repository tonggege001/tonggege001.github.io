---
layout: post  
title: 2021-10-06-Python 核心
date: 2021-10-06
categories: blog
tags: [Python,编程语言]
description: 2021-10-06-Python 核心笔记
---   

# 1-Python 数据模型  
## Python 特殊方法  
Python特殊方法是为了被Python解释器所调用的，自己并不需要调用它。也就是没有MyObj.\_\_len\_\_()这种写法，而只需要调用len(MyObj)。有时候，特殊方法的调用是隐式的，比如 for i in x: 语句中，背后其实用的是iter(x)，而这个函数背后则是x.\_\_iter\_\_().  
```python  
__repr__(), __abs__(), __add__(), __mul__()
```
上面集合函数都是python特殊方法，可以理解为运算符重载。\_\_repr\_\_()表示把对象当成字符串进行输出，\_\_str\_\_()类似，但是不同的是python会先调用repr。  

如果为了判断一个值x是真还是假（例如if, while），python会调用bool(x)，也就是说需要内部实现\_\_bool\_\_()。其他的特殊方法如下：  
书P11页  

map(function, iterable): 会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。  

filter(function, iterable): 用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。  

## 不可变类型  
Python的每个对象都分为可变和不可变，主要的核心类型中，数字、字符串、元组是不可变的，列表、字典是可变的。对不可变类型的变量重新赋值，实际上是**重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象**（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）。

不可变类型以int类型为例:实际上 i += 1 并不是真的在原有的int对象上+1，而是重新创建一个value为6的int对象，i引用自这个新的对象。代码如下：  
```python  
>>> i = 5
>>> i += 1
>>> i
6
```

# 2-数据结构  
元组拆包作为函数参数：  
```python  
t = (20, 8)
divmod(*t)

a, b *rest = range(5)       # 只想到前两个数据
a, b, _ = (1, 2, 3)
```  

切片s[a : b : c]: 对s在a和b间以步长为c进行取值，若c为负数则反向取值。实际上是调用\_\_getitem\_\_(slice(start, stop, step))获得元素的，slice是一个获得下标序列的函数。  

## list.sort和sorted  
list.sort就地排序，会改变list，sorted会返回一个可迭代对象。
> 参数：reverse: 从大到小排序  
> key: 排序算法依照的关键字，key=func，会调用func(data)

## bisect 管理已排序的序列  
**bisect(haystack, needle)** 
在haystack里搜索needle的位置，该位置满足的条件是，把needle插入这个位置之后，haystack还能保持升序。也就是说这个函数返回的位置前面的值，都小于等于needle的值；haystack必须有序（从小到大）。

```python
import bisect
import sys

HAYSTACK = [1,4,5,6,8,12]
NEEDILES = [0, 1, 2, 5, 30]

def demo(bisect_fn):
    for needle in reversed(NEEDLES):
        position = bisect_fn(HAYSTACK, needle)
        offset = position * ' |'
        print('{0:2d} @ {1:2d}  {2}{0:<2d}'.format(needle, position, offset))

if __name__ == "__main__":
    if sys.argv[-1] = "left":
        bisect_fn = bisect.bisect_left
    else:
        bisect_fn = bisect.bisect_right     # 可以简写为bisect。bisect，别名关系
    demo(HAYSTACK)
```  

**insort(seq, item)**  
把变量item插入到seq中，并保持升序。insort也有对偶的insort_left。他们的作用是把相等的元素放在左边还是放在右边。这两个函数都有lo和hi来控制搜索的范围。  

## 数组  
数组array.array比list更高效，并且支持所有跟可变序列有关的操作，包括pop、insert和extend，另外，数组还提供从文件读取和存入文件的更快方法：frombytes和tofile。  

数组的创建需要类型码，比如'b'代表有符号字节数(-127到128)。  

## 双向队列  
collections.deque类（双向队列）是一个线程安全、可以快速从两端添加或删除元素的数据类型。
> 如果想要一种数据结构来存放“最近用到的几个元素”，deque也是一个很好的选择，这是因为在新建一个双向队列的时候可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素。  

常用方法：  
**rotate(num)**：向右旋转num个元素；num为负时，向左翻转。  
**append(elem)**  
**append_left(elem)**  
**extend(iter)**  
**extend_left(iter)**  

## 堆 heapq  
提供了heappush和heappop方法，让用户把可变序列当成堆队列或者优先队列。堆排序：  
```python  
def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]

heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
```  

# 3-字典和集合  
只有可散列集合才能做key，值不要求是否可散列。  
> 可散列要实现__hash__()和比较函数__qe__()。原子不可变数据(str, bytes和数值类型)都是可散列类型，frozenset也是，元祖的话，只有当一个远足包含的所有元素都是可散列的，它才是可散列的。  

## 常见映射方法  
|函数|说明|
|:----:|:----:|  
|clear()|移除所有函数|
|\_\_contains__(k)|检查key是否在d中|
|copy|浅复制|  
|\_\_delitem(k)__|移除键为k的元素，相当于del d[k]|
|fromkeys(it, [initial])|将迭代器中的元素映射为key，value要么是initial要么是None|  
|get(k,[default])|返回键k的对应值，如果字典里没有键k，则返回None或者default|  
|\_\_getitem__()|同上|
|items()|返回所有键值对|
|\_\_iter__()|获取键的迭代器|
|keys()|获取所有键|
|len|长度|
|pop(k, [default])|返回键k所对应的值，然后移除这个键值对|
|popitem()|随即返回一个键值对并从字典里移除它|
|setdefault(k, [default])|若字典里有key则将值设置为default，若无，则d[k]=default|
|update(m, [**args])|m 是可叠戴器，用来更新d中的条目|
|values()|返回字典里的值|  

## collections.OrderedDict  
这个类型在添加键时会保持顺序，因此键的迭代次序总是一致的。  

## collections.Counter  
这个类型会给键准备一个整数计数器，每次更新一个键时都会增加这个计数器，或者当作多重集合来用。例如：  
```python  
import collections  

>>> ct = collections.Counter("abracadabra")
Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

>>> ct.update('aaaaazzz')
Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

ct.most_common(2)
[('a', 10), ('z', 3)]
```  

## 不可变映射类型  
from type import MappingProxyType  
如果给这个类一个映射，它会返回一个只读视图，但它是动态的，这意味着如果对原映射做出改动，我们通过这个视图是可以观察到，但无法对其做出修改。  

## 集合  
Python集合分为set和frozenset，set不可散列，frozenset可以散列。集合还实现了很多孕算法，比如a | b求合集，a & b求交集，a - b 求差集。  

创建方法：  
* l = [1, 2, 3], set(l)
* l = {1, 2, 3}  
* 集合推导：{chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}

# 5-一等函数  
**高阶函数**：把函数作为参数或返回值的函数，例如map, filter, reduce.  

**map**：列表中每个元素做同样的操作。  
**filter**：过滤掉不满足条件的函数。  
 
## Lambda表达式  
Lamda表达式必须只能定义简单的表达式函数，而不能包含while, try等语句。例如：  

```python  
lambda word: word[::-1]     # 对单词进行reverse  
sorted(list, key=lambda word: word[::-1])
```  

## 可调用对象  
判断是否是可调用对象，可以使用内置函数callable()。可调用对象如下：  

* def定义或者lambda定义的函数  
* 内置函数，如len等
* 内置方法，如dict.get
* 方法，在类的定义体中定义的函数
* 类，调用类时会运行类的\_\_new__方法创建一个实例，然后运行\_\_init__方法初始化实例。
* 类的实例，如果定义了__call__方法，那么它的实例也可以调用
* 生成器函数，使用yield关键字的函数或方法，调用生成器函数返回的是生成器对象。

## 函数内省  
函数有很多属性，例如：  
|名称|类型|说明|  
|:----:|:----:|:----:|  
|\_\_annotations__|dict|参数和返回值的注解|
|\_\_call__|method-wrapper|实现()运算符；即可调用对象协议|
|\_\_closure__|tuple|函数闭包，即自由变量的绑定（通常是None）|
|\_\_code\_\_|code|编译成字节码的函数元数据和函数定义体|
|\_\_defaults__|tuple|形式参数的默认值|
|\_\_get__|method-wrapper|实现只读描述符协议|
|\_\_globals__|dict|函数所在模块的全局变量|
|\_\_kwdefaults__|dict|仅限关键字形式参数的默认值|
|\_\_name__|str|函数名称|
|\_\_qualname__|str|函数的限定名称，如Random.choice|  

## 定位参数和仅限关键字参数
一个函数可能会需要一个可变数量的参数，但同时也需要一个或多个关键字参数形式的可选项。目前，实现这一点的唯一方法是同时定义一个可变参数vargas和一个’keywords’参数（kwargs），然后手动从字典中提取出可用的关键字。

从语法上讲，本篇文章提议的更改相当简单，第一个改变是允许常规参数出现在可变参数之后（此时这个常规参数就是一个仅限关键字参数。强制性的，它只能通过关键字传参。例如下面的函数可以接受任意数量的位置参数，同时也可以接受一个关键字参数 'case_sensitive'。因为这个关键字参数选项绝对不会被位置参数填充，而是必须显式的通过名字指定填充，所以称为仅限关键字参数。
仅限关键字参数不需要有默认值， 由于Python需要将所有的参数都绑定一个值，而且将值绑定到关键字参数的唯一方法是通过这个关键字，因此这种参数是‘需要关键字的参数’。所以这些参数必须通过调用方提供，且必须通过关键字提供值。
```python  
# 传入的任意个非关键字参数都会被wordlist捕获
def sortwords(*wordlist, case_sensitive=True):
    ...
```  

第二点语法上的更改是允许省略可变参数的参数名。这意味着对于一个有仅限关键字参数的函数来说，它不会再接受一个可变参数。如下例：
```python  
def compare(a, b, *, key=None):
    ...
```  

第三个是带有关键字的，会存入成字典（变成key, value形式）：  
```python  
def compare(**param):
    ...  
```  
## 函数注解  
如下：  
```python  
def clip(text: str, max_len: 'int > 0'=80) -> str:
    return
```  

Python对注解做的唯一的事情是，把它们存储在函数__annotations__属性里。仅此而已。Python不做检查、不做强制、不做验证，什么操作都不做。  

## 抽象基类  
定义抽象基类的方法如下：  
```python  
from abc import ABC, abstractmethod

class Promotion(ABC): 
    @abstractmethod
    def discount(self, order):
        '''to be implemented'''
```

# 7-函数装饰器和闭包  
函数的装饰器用于在源码中标记函数，**以某种方式增强函数的行为**。这是一项强大的功能，但是若想掌握，必须理解闭包。  

nolocal是最新出现的保留关键字，在Python3.0引入。出了装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。  

## 装饰器的基础知识  

装饰器是可调用的对象，其参数时另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。假如有个名为decorate的装饰器：  
```python  
@decorate
def target():
    print("running target()")
```  
上述代码的效果与下述写法一样：  
```python  
def target():
    print("running target()")

target = decorate(target)
```  

## 装饰器执行的时机  
装饰器在被装饰的函数定义之后立即运行，这通常是**导入时（也即加载模块时）**，也就是先于\_\_main__函数被调用。多数装饰器会修改被装饰的函数，通常它们会定义一个内部函数，然后将其返回，替换被装饰的函数。  

## 变量作用域规则  

1. 函数体内定义了与全局变量同名的变量，则会在函数体内将该变量视作局部变量。  

```python  
b = 6
def f2(a):
    print(a)
    print(b)
    b = 9

f2(3)
```  
输出：  
3  
Traceback (most recent call last):  
  File "\<stdin\>", line 1, in \<module\>  
  File "\<stdin\>", line 3, in f2
UnboundLocalError: local variable 'b' referenced before assignment  
原因：Python变异函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。如果在函数中赋值时想让解释器把b当成全局变量，要使用global声明：  
```python  
b = 6  
def f3(a):
    global b
    print(a)
    print(b)
    b = 9

f3(3)
```  
输出：  
3  
6  

> 可以比较字节码：  
> from dis import dis
> dis(f1)
> 0 LOAD_GLOBAL 0 (print)
> 3 LOAD_FAST   0 (a)
> 6 CALL_FUNCTION 1 (1 positional, 0 key word pair)  
> ...

## 闭包  
只有涉及嵌套函数时才有闭包问题。  

闭包指延伸了作用域的函数，指的是函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没关系，关键是它能访问定义体之外定义的非全局变量。  

## nonlocal声明  

下面是一个问题代码：  
```python  
def make_averager():
    count = 0
    total = 0
    def averager(new_value):
        count += 1
        total += new_value
        return total / count

    return averager
```  

尝试运行如下代码：  
```shell  
>>> avg = make_averager()
>>> avg(10)  
Traceback (most recent call last):  
...  
UnboundLocalError: local variable 'count' referenced before assignment  
```  

原因：Python中数字是不可变类型，执行count += 1时，实际上是count = count + 1一样。因此我们在averager的定义体中count赋值了，这相当于产生一个新的变量，然后讲count与新的变量绑定，此时count变成了局部变量。而列表是可变类型。对于不可变类型（数字、字符串、元组），只能读取，不能更新，如果尝试重新绑定则相当于创建一个局部变量count，这样count就相当于局部变量而不是自由变量，因此不会保存在闭包中。  

为了解决这个问题，Python3引入了nonlocal关键字，它的作用是把变量标记为自由变量，这样即使变量被更新也还是自由变量。    

正确的例子：  
```python  
def make_averager():
    count = 0
    total = 0
    def averager():
        nonlocal count, total
        count += 1
        total += new_value
        return total / count  
    
    return averager  
```  

## functools.wraps装饰器  
上面的装饰器掩盖了被装饰函数的\_\_doc__和\_\_name__属性，使用functools.wraps装饰器能够把相关的属性从被装饰的函数复制到返回的函数中，此外还能处理关键字参数（上面的不可以）。  

例子：  
```python  
import time  
import functools  

def clock(func):
    @functools.wraps(func)  # 这其实也是个装饰器，用来复制各个参数的
    def clocked(*args, **kwargs):
        t0 = time.time()
        result = func(*args, **kwargs)  
        elapsed = time.time() = t0  
        name = func.__name__  
        arg_lst = []
        if args:  
            arg_lst.append(', '.join(repr(arg) for arg in args))  
        
        if kwargs:  
            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]  
            arg_lst.append(', '.join(pairs))
        arg_str = ', '.jpoin(arg_lst)
        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
        return result  
    
    return clocked
```  

## 标准库中的装饰器  

### 使用functools.lru_cache记忆化搜索  
functools.lru_cache是非常实用的装饰器，它实现了备忘(memorization)功能。这是一项优化技术，它把耗时的结果保存起来，避免传入相同的参数时重复计算。LRU代表着缓存不会无限增长，一段时间不用的缓存条目会被扔掉。  

生成第n个斐波那契慢速递归可以使用lru_cache，如下：  
```python  
import functools  

# 之前自己定义的计时操作  
from clockdeco import clock

@functools.lru_cache()            # --> 1
@clock                            # --> 2
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-2) + fibonacci(n-1)

if __name__ == "__main__":  
    print(fibonacci(6))
```  
**1**: 这里必须带括号，因为装饰器里可以接受参数。
**2**: 这里叠放装饰器，@lru_cache()应用到@clock返回的函数上。  

lrc_cache可以使用两个可选的参数来配置。它的签名是：  
```python  
functools.lru_cache(maxsize=128, typed=False)
```  
typed参数表示把不同参数类型分开包村还是保存成一个变量(如1和1.0)。lru_cache使用字典存储结果，而且键根据传入的定位参数和关键字参数创建，所以被lru_cache装饰的函数，它的所有参数都必须是可散列的。  

### 单分派泛函数  
我们是想根据传入的参数按照不同的类型返回不同的字符串结果，因为Python不支持函数重载，所以可以使用Python的singleddispatch装饰器。示例：  
```python  
from functools import singledispatch  
from collections import abc
import numbers
import html  

@singledispatch                         # ---> 1
def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)

@htmlize.register(str)                  # ---> 2
def _(text):                            # ---> 3
    content = html.escape(text).replace('\n', '<br/>\n')
    return '<p>{0}</p>'.format(content)

@htmlize.register(numbers.Integral)     # ---> 4
def _(n):
    return '<pre>{0} (0x{0:x})</pre>'.format(n)

@htmlize.register(tuple)                # ---> 5
@htmlize.register(abc.MutableSequence)
def _(seq):
    inner = '<li>\n</li>'.join(htmlize(item) for item in seq)
    return '<ul>\n<li> '+ inner +'<li/> \n </ul>' 
```  
**1**: @singledispatch标记处理object类型的基函数。  
**2**: 各个专门函数使用@\<\<base_function>>.register(\<\<type>>)装饰。  
**3**: 专门函数的名称无关紧要；\_是个不错的选择  
**4**: 为每个需要特殊处理的类型注册一个函数。numbers.Integral是int的虚拟超类。  
**5**: 可以叠放多个register装饰器，让同一个函数支持不同类型。  

## 参数化装饰器
如何实现参数化装饰器？答案是创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。例子：  

```python  
registry = set()
def register(activate=True):
    def decorate(func):      # 这个是真正的装饰器，输入是函数，输出是函数
        print("running register(activate=%s)->decorate(%s)"%(active, func))

        if active:
            registry.add(func)
        else:
            registry.discard(func)
        return func
    
    return decorate

@register(active=False)
def f1():
    print("running f1()")

@register()
def f2():
    print("running f2()")

def f3():
    print("runningf3()")
```  
这里的关键是register()要返回decorate，然后把它应用到被装饰的函数上。  


# 8-对象引用、可变形和垃圾回收  
Python变量不是盒子，而是存储空间的一个引用。  

## ==和is之间的选择  
\=\=运算符比较两个对象的值（对象中保存的数据），而is比较对象的标识。通常只关注值，所以\=\=出现的频率高。  
在变量和单例值之间比较时，应该使用is。比如最长使用is检查变量绑定的值是不是None，下面是推荐写法：  
```python  
x is None
```  
否定是：  
```python  
x is not None  
```  

实际上\=\=是语法糖，等同于a.\_\_eq\_\_(b)。继承自object的\_\_eq\_\_()方法，但多数内置类型使用更有意义的方式覆盖了\_\_eq\_\_()。  

## 默认做浅复制  
构造方法或者[:]做的都是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。  

**为任意对象做深复制**：  
copy模块提供deepcopy()和copy()函数能为任意对象做深复制和浅复制。  
```python  
import copy  

l = ["alice", "bob"]
new_list = copy.deepcopy(l)
```  

## 函数的参数作为引用时  
* Python函数传参数传递的是引用。  
* 不要使用可变类型作为参数默认值（def aaa(l=[]))  

## del 和垃圾回收  
对象不会自行销毁；然而，无法得到对象时，可能会被当作垃圾回收。  
del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。  

> 有个\_\_del\_\_特殊方法，但是它不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用\_\_del\_\_方法，给实例最后的机会释放外部资源。  

在CPython中，垃圾回收使用的主要算法是引用计数。实际上每个对象会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁。


### Python 垃圾回收机制  
python 采用的是**引用计数**机制为主，**标记 - 清除**和**分代收集**两种机制为辅的策略。  

**引用计数**：  
* Python 语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早 George E. Collins 在 1960 的时候首次提出，50 年后的今天，该算法依然被很多编程语言使用。
* 『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
* 它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的 “循环引用”，因此，也有很多语言比如 Java 并没有采用该算法做来垃圾的收集机制。  

**导致引用计数 +1 的情况：**
* 对象被创建，例如 a=23
* 对象被引用，例如 b=a
* 对象被作为参数，传入到一个函数中，例如func(a)
* 对象作为一个元素，存储在容器中，例如list1=[a,a]

**导致引用计数-1 的情况：**
* 对象的别名被显式销毁，例如del a
* 对象的别名被赋予新的对象，例如a = 24
* 一个对象离开它的作用域，例如 f 函数执行完毕时，func函数中的局部变量（全局变量不会）
* 对象所在的容器被销毁，或从容器中删除对象

**循环引用导致内存泄漏:**
```python  
def f2():
    '''循环引用'''
    while True:
        c1=A()
        c2=A()
        c1.t=c2
        c2.t=c1
        del c1
        del c2
```  

虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

**标记-清除解决循环引用：**  
Python采用了“标记-清除”(Mark and Sweep)算法，解决容器对象可能产生的循环引用问题。(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)。

跟其名称一样，该算法在进行垃圾回收时分成了两步，分别是：
* A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；
* B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。  

<img src="../images/20211006/1.png" style="margin: 0 auto; display: block; height: 18em; "/>  

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从**根对象（root object）**出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 mark-sweepg 在上图中，我们把小黑圈视为全局变量，也就是把它作为 root object，从小黑圈出发，对象 1 可直达，那么它将被标记，对象 2、3 可间接到达也会被标记，而 4 和 5 不可达，那么 1、2、3 就是活动对象，4 和 5 是非活动对象会被 GC 回收。  

**分代回收：**  
在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过“**分代回收**”(Generational Collection)以空间换时间的方法提高垃圾回收效率。

分代回收是基于这样的一个统计事实：**对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。**

python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。

gc的扫描在什么时候会被触发呢?答案是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。

该阈值可以通过下面两个函数查看和调整:  
```python  
gc.get_threshold() # (threshold0, threshold1, threshold2).
gc.set_threshold(threshold0[, threshold1[, threshold2]])  
```  

下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).  
































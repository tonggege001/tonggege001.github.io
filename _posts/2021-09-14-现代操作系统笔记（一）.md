---
layout: post  
title: 2021-09-14-现代操作系统笔记（一）
date: 2021-09-14
categories: blog
tags: [操作系统,技术]
description: 2021-8-4-现代操作系统阅读，记录一下关键的笔记内容。
---  

## 1-进程与线程  
进程：进程是资源分配的最小单位，一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器、变量。也是文件和设备分配的最小单位。  

线程：是程序执行的最小单位，一个进程可以有多个线程，它们共享进程的地址空间和各种资源（线程不共享栈、PC和寄存器，共享堆、全局变量和文件等），线程的存在是为了并行计算，线程的调度是更轻量级的，更容易创建和销毁。若多个线程都是CPU密集型的，那么并行并不能获得性能上的增强，但是若存在着大量的计算和IO处理，那么多个线程允许这些活动彼此重叠进行，从而加快应用程序执行的速度。

几乎所有系统都把进程视为一个容器，用以管理相关资源，如地址空间、线程、打开的文件、权限保护等。线程是比进程更新的概念。

* 在UNIX系统中创建进程只有$fork$函数，在调用完$fork$函数后，这两个父子进程拥有相同的内存映像、同样的环境字符串(PATH等)，和同样的打开文件。子进程会接着执行$execve$类似的系统调用以修改内存映像并运行一个新程序。之所以这样安排，是为了在$fork$之后但在$execve$之前允许孩子进程处理其文件描述符，这样可以完成对标准输入输出和标准错误文件的重定向。Windows和UNIX系统进程创建后，父进程和子进程有**各自不同的地址空间**，在UNIX系统中子进程初始的地址空间是父进程的一个副本，不可写内存区域是共享的，可写的内存区域不共享或者写时复制。
* *进程的终止* 1. 正常退出; 2. 出错退出; 3. 严重错误(除0， 引用内存不存在，非法指令); 4. 被其他进程杀死(kill系统调用)

### 进程的状态  
![](/images/20210914-1.png)  

### 进程的实现  
进程模型是一个进程控制快(PCB)，操作系统通过进程表进行控制，每个表项包括程序计数器，堆栈指针，内存分配状况，所打开文件的状态，账号和调度信息，以及其他进程由于运行态转换到就绪态或阻塞态时必须保存的信息，从而保证进程随后能够再次启动。下图列出需要的大致信息：  
![](/images/20210914-2.png)  

### 线程实现的两种模式  
*在用户空间中实现*  
把整个线程放在用户空间，内核对线程一无所知，从内核角度将就是将进程看成单线程的来调度，在用户空间管理线程时，每个进程需要其专门的线程表。  
优点：1. 创建和调度的开销小，均在用户态下不用转换到内核态；2. 允许用户定制自己的线程调度策略，灵活，这是因为某些垃圾回收线程可能会导致不合适的时刻停止。  
缺点：1. 如何执行阻塞的系统调用，因为一点某个线程阻塞，那么该进程被阻塞，则所有线程都不能运行了。2. 缺页中断也会使所有线程无法执行，直到需要的页面被置换上来。3. 线程永久运行问题，因为线程执行在用户态，是没有时钟中断的，如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程主动放弃CPU。  

*在内核中实现*  
用户空间没有线程表了，而内核空间记录所有线程的线程表。当某个线程希望创建或销毁时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或销毁的工作。  
优点：针对用户态线程所有缺点的反面
缺点：1. 创建销毁调度代价太大

*混合实现*  
使用内核级线程，然后将用户级线程某些或全部内核线程多路复用起来。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用，如同在没有多线程能力操作系统中谋和进程的用户集线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。

### 进程间通信  
InterProcessCommunication(IPC问题)  
1 分为命名管道和无名管道。在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，都可以看成一种特殊的文件，**具有固定的读端和写端**，也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；无名管道一般使用fork函数实现父子进程的通信，命名管道用于没有血缘关系的进程也可以进程间通信；面向字节流、自带同步互斥机制、半双工，单向通信，两个管道实现双向通信。

2 消息队列，在内核中创建一个队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列；消息队列独立于发送与接收进程，可以通过顺序和消息类型读取，也可以fifo读取；消息队列可实现双向通信 。

3 信号量，在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1，通过对临界资源进行保护实现多进程的同步。Mutex就是是一种信号量，kill的SIGNAL也是一种信号量。

4 共享内存，将**同**一块物理内存一块映射到**不同的进程的虚拟地址空间**中，实现不同进程间对同一资源的共享。目前**最快**的IPC形式，不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以，共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。  

5 socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据。socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。是一种可以网间通信的方式。将SOCKET的IP设置为回环地址即可实现进程间通信。  

### 信号量  
使用一个整型变量来累计唤醒次数，供以后使用。Dijkstra建议引入一个新的变量类型叫信号量(semaphore)。一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或为正值（表示有一个活多个唤醒操作）。  
&nbsp;&nbsp; down操作：检查其值是否大于0，若大于0则将其减1并继续操作；若该值为0，则进程将睡眠，而此时down操作未结束。保证一旦一个信号量操作开始，则在该操作完成或阻塞之前，其他进程均不允许访问该信号量。  
&nbsp; &nbsp;up操作：对信号量的值增1，如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则系统选择其中的一个并允许该进程完成它的down操作。于是，对于一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍是0，但在其上睡眠的进程却少一个。信号量的值增1和唤醒一个进程同样是不可分割的。（原论文中down是P操作，up是V操作）。  

注意：若单CPU中只需要屏蔽中断即可实现原子操作，若多CPU中，需要使用mutex来保护信号量，通过TSL或XCHG指令来防止几个CPU同时访问一个信号量。  

### 互斥量  
如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本吗，成为互斥量(Mutex)。互斥量适用于管理共享资源或一小段代码。互斥量是处于两态之间的变量：解锁和加锁。互斥量分为两个过程：当一个线程或进程需要访问临界区时，它调用mutex_lock，如果该互斥量当前是解锁的，则调用成功，线程可以自由进入该临界区；如果该互斥量已经加锁，调用线程被阻塞，直到临界区中的线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。

### 进程调度  

**进程调度切换的代价**  
首先用户态必须切换到内核态；然后要保存当前进程的状态，包括进程表中存储寄存器值以便以后重新装在。在许多系统中，内存映像（例如页表内的内存访问位）也必须保存；接着，通过运行调度算法选定一个新进程；之后将新进程的内存映像重新装入MMU；最后新进程开始运行。除此之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。  

**何时被调度**  
1. 在创建新进程时，决定运行夫进程还是子进程，随机选择  
2. 在一个进程退出时，选择就绪状态的进程，如果没有则运行系统提供的一个空闲进程
3. 当一个进程阻塞在I/O和信号量上或其他原因阻塞，必须选择另一个进程运行
4. 在一个I/O中断发生时，必须做出调度决策

**非抢占式**调度算法挑选一个进程运行到结束或者阻塞而不会主动退出；**抢占式**调度算法挑选一个进程，让该进程运行某个固定时段的最大值。如果该时间段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另外的进程运行。进行抢占式调度处理，需要在时间间隔末端发生时钟中断，以便把CPU控制返回给调度程序。

**批处理系统中的调度**
先来先服务、最短作业优先、最短剩余时间优先（如果新的服务到来，若比当前进程的剩余时间还少，则先运行新进程）  

**交互式系统的调度**  
轮转调度：每个进程被分配一个时间片，在该时间片内运行  
优先级调度：每个进程赋予一个优先级，优先级高的先被运行，在时钟中断时调整优先级     
多级队列：设立优先级类。属于最高优先级的进程运行一个时间片，属于次高优先级类的进程运行2个时间片，再次一级的运行4个时间片，以此类推。当一个进程完成分配时间片后，它被移到下一个类。例如：一个需要连续计算100个时间片的进程，它最初被分配一个时间片并被优先调度，运行完后退出，下次它将获得两个时间片，接下来是4, 8, 16, 32和64.当然最后一次它只需要使用37个时间片就可以工作，这样只需要7次交换。  
最短进程优先  
彩票调度： 为进程提供各种系统资源（如CPU时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源，这样使$n$个进程平均得到$1/n$的CPU时间。  
> 彩票调度可以解决其他调度问题：有一个视频服务器，在该视频服务器上若干进程正在向其客户提供视频流，每个视频流的帧速率都不相同。假设这些进程需要的帧速率分别是10，20，25，。如果给这些进程分配10，20，25张彩票，那么它们会自动按照大致正确的比例(即10,20,25)划分CPU的使用。  

**操作系统调度的策略与机制**  
调度算法并没有接受用户进程的调节信息，但是用户的父进程里有许多子进程，他们的重要性并不相同，所以这样父进程无法调整子进程的优先级。假设内核使用优先级调度算法，并提供一条可供进程设置(并改变)优先级的系统调用。这样尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。这里调度机制位于内核，调度策略由用户进程决定。策略与机制分离是一种关键性思路。  

### 哲学家就餐问题  
五个人必须满足左右两边都没有人就餐时才可以就餐。  

### 进程和线程的小结  
几乎所有系统都把进程视为一个容器，用以管理相关资源，如地址空间、线程、打开的文件、权限保护等。线程是比进程更新的概念。

## 2-内存管理  
*地址空间*：地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间，处理在一些特殊情况下进程需要共享它们的地址空间外。  

*基址寄存器与界限寄存器*：通过基址寄存器进行重定位，界限寄存器控制程序长度防止越界。  

*交换技术*：把一个进程完整地调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以它=当它们不运行时就不会占用内存。  

*虚拟内存*：该策略甚至能使程序在只有一部分被调入内存的情况下运行。  

### 虚拟内存  
产生虚拟内存的原因：单个程序都已经大到内存无法容纳了，交换技术已经没办法适应这种情况。  
基本思想：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块被称为一页或页面。每一页有连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。  

#### 分页  
由程序产生这些地址称为**虚拟地址**，它们构成了虚拟地址空间。虚拟地址不是被直接送到内存总线上，而是被送到**内存管理单元(MMU)**，MMU把虚拟地址映射为物理地址，如下图：  
![](/images/20210914-3.png)  
虚拟地址空间按照固定大小划分成被称为页面的若干单元，如下所示：  
![](/images/20210914-4.png)  
当一个页面访问未被映射的地址时，MMU注意到该页面没有被映射，于是使CPU陷入到操作系统，这个陷阱被称为缺页中断或者缺页错误(page fault)。操作系统找到一个很少使用的块把它的内容写入磁盘（如果它不在磁盘上）。随后吧需要访问的页面读到刚才回收的块中，修改映射关系，然后重新启动陷入的指令。可用页号作为也表的索引以得出位于该虚拟页面的块号。  

### 页表  
每个进程都有一个页表，多级页表或者单级页表。页表的结构如下图：  
![](/images/20210914-5.png)
![](/images/20210914-6.png)  
虚拟页号可做页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到块号（如果有的话）。然后把块号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址，页表的目的就是把虚拟页面映射为块。  

高速缓存禁止位：映射到设备寄存器而不是常规内存的页面很有用。  
加速分分页过程：  
硬件TLB和软件TLB。TLB项一般256个左右。  

**多级页表**  
引入多级页表的原因是避免把全部页表一直保存在内存中。  
![](/images/20210915-2.png)

另外一种是倒排页表，就是页表项和块号对应，而不是和页号对应，然后用软件管理和散列表来实现正向查找。  

### 页面置换算法  
当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。置换算法还用在高速缓冲Cache和Web服务器的页面放在告诉缓存里。  
* 最优页面置换算法  
* 最近最少使用(LRU)算法，最近最少未使用的页面被换出  
* 先进先出算法  


一般页面置换算法分为局部的（单个进程内最老的页面进行替换）和全局的（对所有进程多有页来替换最老的那个）。一般情况下全局的更好。  

减少竞争内存的一个好方法是将一部分进程交换到磁盘，并释放他们所占有的所有页面，这样可以减少颠簸的发生（页面被频繁置入置出）。  

一般情况下内核用大页面，用户进程用小页面。  

### 共享页面  
几个不同用户同时运行同一个程序很常见，显然为了避免在内存中使用同一个页面的两个副本，共享页面效率更高。（只读页面可以共享，数据页面不能共享）。  

如果系统支持指令和数据分离的地址空间，则可以使用页表指针来实现共享页面，使指令页面地址指针指向同一个页面即可实现共享。但是会带来一个问题：某个程序运行结束后，需要会查找所有页表，确保该页没有其他进程引用才能释放，然而这样代价很大，需要额外设计数据结构解决。  

共享数据页面实际上也可以实现：linux $fork$后父子进程指向相同的数据页面，当对某些页进行修改时，会出发只读保护，并引发操作系统陷阱。然后会生成一个该页的副本，这两个副本是可读写的，这称为写时复制。  

### 共享库  
> 静态库 任何在被目标文件.o 调用了但是没有被定义的函数(比如printf)，都被称作未定义外部函数。链接器会寻找这些未定义外部函数，如果找到了，则将他们家在到可执行二进制文件中。例如printf需要write，如果write还没有被夹在进来，则链接器就会参照write并在找到后把它加进来，当链接器完成任务后，一个可执行二进制文件被写到磁盘。
> 缺点：浪费磁盘空间和内存空间

> 共享库 当和共享库链接时，链接器没有加载被调用的函数，而是夹在一小段能够在运行时绑定被调用函数的存根例程(stub routine)。共享库在第一次被调用时装在，并且并不是一次性读入内存，而是根据需要，以页面为单位装在的，因此没有被调用的函数不会被装在到内存  
> 优点：共享库更新时，不需要重新编译整个可执行文件。

**共享库出现的问题**  
如果库的第一个指令是跳转到第16的位置，如果被唯一进程装载，那么可以通过重定向来解决（也就是跳转到base+16的位置），但是如果进行共享，两个程序对于共享库的起始位置不一样，那么跳转到第16的位置就不正确，所以可通过编译指令使共享库内的程序地址跳转只使用相对跳转，比如相对当前PC+X的位置跳转。  

### 内存映射文件  
将一个文件映射到其虚拟地址空间的一部分，可以将文件当成一个内存中的大字符数组来访问，而不用通过读写操作访问这个文件。  
如果两个或以上的进程同时影射了这个文件，它们就可以通过**共享内存**来通信。因此这个机制提供了一个进程之间的高带宽通道。  

### 虚拟内存接口  
有些情况下，向程序员提供页面映射的，这样可以实现共享内存，通过让一个进程把一片内存区域的名称通知另一个进程，而使得第二个进程可以把这篇区域映射到它的虚拟地址空间去，通过两个进程共享同一部分页面，高带宽的共享就成为可能。  

### 有关分页具体实现的内容  

**分页有关的工作**  
*进程创建时*：确定程序和数据初始时有多大，并为它们创建一个页表，为页表分配空间并初始化。当进程被换出时，页表不需要驻留在内存中，但当进程运行时，它必须在内存中。操作系统要用程序和数据对交换分区进行初始化，某些系统直接对磁盘上可执行程序进行分页，以节省磁盘空间和初始化时间，操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。  

*进程执行时*：必须为新进程重置MMU，刷新TLB，以清除以前的进程遗留下的痕迹。新进程的页表必须成为当前页表，通常可以通过复制该页表活把上一个指向它的指针放进某个硬件寄存器来完成。有时可以在进程初始化时把部分或者全部页面装入内存中以减少却也中断的发生，例如PC(程序计数器)所指的页面肯定是需要的。  

*缺页中断发生时*：操作系统必须通过读硬件寄存器来确定是哪个虚拟地址造成了缺页中断。通过该信息计算需要哪个页面，并在次盘上对该页面进行定位，它必须找到合适的块来存放新页面并置换出老页面，然后把所需的页面读入页框。最后回退PC，使程序计数器指向引起缺页中断的指令，并重新执行该指令。  

*进程退出时*：操作系统必须释放进程的页表、页面和页面在硬盘上所占用的空间。如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止使，才可以释放内存和磁盘上的页面。  

**缺页中断处理**  
![](/images/20210914-8.png)
![](/images/20210914-9.png)
**指令备份**  
因为缺页中断要重新执行原来的指令，那么解决方法是用一个隐藏的寄存器来记录上一个程序计数器的值。  













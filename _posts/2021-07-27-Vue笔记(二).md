---
layout: post
title: 2021-07-27-Vue笔记（二）
date: 2021-07-27
categories: blog
tags: [前端]
description: Vue笔记（二）
---  

## Vue CLI 使用  
CLI是一个全局安装的npm包，提供了终端里的vue命令。他可以通过**vue create**快速搭建一个新项目，或者直接通过**vue serve**构建新想法的原型，也可以通过vue ui图形化界面管理所有项目。CLI服务是构建于webpack和webpack-dev-server之上的，包含加载其他CLI插件的核心服务；一个针对绝大部分应用优化过的内部的webpack配置；项目内部的vue-cli-service命令提供serve、build、inspect命令。

### 安装  
``` shell  
npm install -g @vue/cli  

# 或者  
yarn global add @vue/cli
```
安装完毕后检查：  
```shell  
vue --version
```  

### 快速原型开发  
也就是只创建一个.vue/.js文件就让其运行，首先全局安装:  
```shell  
npm install -g @vue/cli-service-global
```  
vue serve:   
首先需要一个App.vue文件：  
```html  
<template>
    <h1>Hello</h1>
</template>
```  
 然后在这个App.vue目录下运行：  
 ```shell  
vue serve
 ```
vue serve 使用了和vue create创建项目相同的默认设置(webpack、Babel、PostCSS和ESLint)。它会在当前目录自动推导入口文件，入口可以是main.js、index.js、App.vue、app.vue中的一个。你也可以显式地指定入口文件：  
```shell  
vue serve MyComponent.vue
```  

如果需要，还可以提供一个index.html、package.json、安装并使用本地以来、甚至通过相应的配置文件配置Babel、PostCSS和ESLint。  

vue build  
* --target \<target\> 构建目标(app | lib | wc | wc-async, 默认值：app)  
* --name: 库的名字或Web Components组件的名字，默认值为入口文件名  
* -d/--dist \<dir\> 输出目录，默认值dist  

也可以使用vue build 将目标文件构建成一个生产环境的包并用来部署。  
```shell  
vue build MyComponent/vue
```  


### 创建一个项目  

```shell
vue create hello-world  
```  
会提示使用Vue的各种特性。使用图形化界面管理：  
```shell  
vue ui  
```  

### 插件和Preset  
每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。当你使用 vue create 来创建一个新项目的时候，有些插件会根据你选择的特性被预安装好。如果你想在一个已经被创建好的项目中安装一个插件，可以使用 vue add 命令：  
```shell  
vue add eslint
```  
一个 Vue CLI preset 是一个包含创建新项目所需预定义选项和插件的 JSON 对象，让用户无需在命令提示中选择它们。

在 vue create 过程中保存的 preset 会被放在你的 home 目录下的一个配置文件中 (~/.vuerc)。你可以通过直接编辑这个文件来调整、添加、删除保存好的 preset。

这里有一个 preset 的示例：  
```js  
{
  "useConfigFiles": true,
  "cssPreprocessor": "sass",
  "plugins": {
    "@vue/cli-plugin-babel": {},
    "@vue/cli-plugin-eslint": {
      "config": "airbnb",
      "lintOn": ["save", "commit"]
    },
    "@vue/cli-plugin-router": {},
    "@vue/cli-plugin-vuex": {}
  }
}
```  
Preset 的数据会被插件生成器用来生成相应的项目文件。除了上述这些字段，你也可以为集成工具添加配置：  
```shell  
{
  "useConfigFiles": true,
  "plugins": {...},
  "configs": {
    "vue": {...},
    "postcss": {...},
    "eslintConfig": {...},
    "jest": {...}
  }
}
```  
这些额外的配置将会根据 useConfigFiles 的值被合并到 package.json 或相应的配置文件中。例如，当 "useConfigFiles": true 的时候，configs 的值将会被合并到 vue.config.js 中。  

### 使用CLI服务  
在一个Vue CLI项目中，@vue/cli-service安装了一个名为vue-cli-service的命令，可以在npm scripts中以vue-cli-service、或者从终端中以./node_modules/.bin/vue-cli-service访问这些命令。  

默认的preset的项目的package.json：  
```js  
{
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build"
  }
}
```  
然后通过npm run serve 调用。  

vue-cli-service serve  
用法： vue-cli-service serve [options] [entry]  

选项：  
* --open 在服务器启动时打开浏览器
* --copy 在服务器启动时将URL复制到剪切板  
* --mode 指定环境模式，默认developement  
* --host 指定host，默认0.0.0.0  
* --port 指定端口，默认8080  
* --https 使用https，默认值false  

vue-cli-service serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。  
除了通过命令行参数，你也可以使用 vue.config.js 里的 devServer 字段配置开发服务器。  
命令行参数 [entry] 将被指定为唯一入口，而非额外的追加入口。尝试使用 [entry] 覆盖 config.pages 中的 entry 将可能引发错误。  

vue-cli-service build  
```shell  
用法：vue-cli-service build [options] [entry|pattern]  

选项：

--mode        指定环境模式 (默认值：production)  
--dest        指定输出目录 (默认值：dist)  
--modern      面向现代浏览器带自动回退地构建应用
--target      app | lib | wc | wc-async (默认值：app)  
--name        库或 Web Components 模式下的名字 (默认值：package.json 中的 "name" 字段或入口文件名)  
--no-clean    在构建项目之前不清除目标目录  
--report      生成 report.html 以帮助分析包内容  
--report-json 生成 report.json 以帮助分析包内容  
--watch       监听文件变化  
```  
vue-cli-service build 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。

这里还有一些有用的命令参数：
--modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。

--target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。

--report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。


vue-cli-service inspect  

```shell  
用法：vue-cli-service inspect [options] [...paths]  

选项：  

--mode    指定环境模式 (默认值：development)  
```
你可以使用 vue-cli-service inspect 来审查一个 Vue CLI 项目的 webpack config。  

### 浏览器兼容性  
你会发现有 package.json 文件里的 browserslist 字段 (或一个单独的 .browserslistrc 文件)，指定了项目的目标浏览器的范围。这个值会被 @babel/preset-env 和 Autoprefixer 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。  

## 2-前端渲染和后端渲染  
**后端渲染**：JSP/PHP+Html和CSS来写出一个网页，传到浏览器里让浏览器显示出来。服务器已经将网页渲染好，而不是使用ajax等请求来渲染。  
后端处理路由和页面的映射关系，就叫做后端路由。

**前后端分离阶段**: 随着Ajax发展，后端只负责提供数据，不负责提供任何界面的内容。一共有两个服务器，静态资源服务器、API服务器。浏览器输入url后，首先向静态资源服务器请求，拿到html, css, js拿过来，然后浏览器直接渲染，js代码由浏览器执行。在执行过程中如果有ajax后会向API服务器发送请求。API服务器返回数据后，会再通过其他的js代码创建div标签，将元素标签插入到html，再将js的东西渲染到网页里。  
前端渲染：浏览器显示的网页中大部分内容都是由前端写的js代码在浏览器中执行渲染出来的网页。优势：API请求可以在各种平台上使用。  

**单页面富应用阶段：**在前后端分离的基础上加了一层前端路由，也就是前端来维护一套路由规则。一般情况下，整个网站只有一个html页面。一般由两个服务器，静态资源服务器和API服务器，静态资源服务器放html+css+js。在前后端分离阶段放了好几套html+css+js -> url1，有很多html, css, js。而SPA只有一个index.html，甚至只有一个css和js。  
假如一个人开发了codewhy.com，则会向静态服务器请求index.html+css+js，全部资源请求下来。通过点击导航栏的按钮，下方显示该显示的内容，也就是说虽然下载下来，但是并不是全部都会渲染。前端路由会配置一些映射关系，当点击每一个导航按钮时，会生成一个url，例如codewhy.com/home或者codewhy.com/about，生成的url不会向服务器请求资源，而是通过js抽取出来的资源显示在页面里。这些资源都是Vue的组件。这些必须用前端路由支持，用于映射前端需要渲染那些组件的。  
前端路由核心：一旦url发生改变，整个页面不刷新。

## 3-前端路由Vue-Router  
通过某些方案让更改url后不刷新页面。  
1. URL的hash  
location.hash = "aaa"  // 则url地址栏变成http:xxx.xxx.xx/aaa  

2. history的pushState()方法。  
history.pushState({}, "", "aaa");  
history.pushState({}, "", "bbb");  
history.pushState({}, "", "ccc");  
这个方法将所有url压入栈。如果history.back()，则退栈，返回上一个url。


history.replaceState({}, "", "aaa");  
上面方法则会替换当前url，不能返回了。  

3. history模式的go  
如果之前已经pushState了aaa,bbb,ccc, ddd，那么还可以通过history.go跳转，例如history.go(-1)则栈弹出一个，go(-2)则栈弹出两个，go(2)则进栈两个。  
history.back() == history.go(-1);  
history.forward() == history.go(1);  

vue-router是基于路由和组件的，路由用于设定访问路径，将路径和组件映射起来；在vue-router的单页面应用中，页面的路径的改变就是组件的切换。

### 安装和使用vue-router
步骤一：  
```shell  
npm install vue-router --save
```  

步骤二：  
在模块化工程中使用它，因为是一个插件，所以可以通过Vue.use()来安装路由功能。  
* 导入路由对象，并调用Vue.use(VueRouter)
* 创建路由实例，并传入路由映射配置  
* 在Vue实例中挂载创建的路由实例  

安装完毕后在src/router下多了个文件夹(没有则自己创建)  
在router文件夹下创建一个index.js，并配置路由相关信息：  
```js  
import VueRouter from "vue-router";  
import Vue from "vue";  

// 通过Vue.use(插件)，安装插件，所有插件都要Vue.use
Vue.use(VueRouter);  

routers = []            // 这里配置映射关系

// 创建路由对象  
const router = new VueRouter({
    // 配置路径和组件之间的应用关系
    routers
});  

// 将router对象传入到Vue实例，在new Vue（）里挂载
export default router;
```

在main.js下：  
```js  
import Vue from "vue";
import App from "./App"
import router from "./router"

Vue.config.productionTip = false

new Vue({
    el: "#app",  
    router: router,
})

```


**使用路由组件**：  
1. 创建路由组件  
2. 配置路由映射：组件和路径映射关系
3. 使用路由，通过\<router-link\> 和 \<router-view\>
在src/component目录下创建组件，比如创建Home.vue组件和About.vue，并填写好组件内容。  
在src/router/index.js下面配置routers:  
```js  
import Home from "../components/Home"  
import About from "../component/About"  

const routers = [
    {
        path: "/home",
        component: Home,
    },
    {
        path: "",
        component: About,
    }
]
```  

为了让其显示，则可以在App.vue里设置两个标签，通过点击不同的标签让其跳转到不同的component。  
App.vue:  
```js  
<template>
  <div id="app">
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <router-view></router-view>     // 占位，表示显示内容
  </div>
</template>  

<script>
export default {
    name: "App"
}
</script>  

<style>

</style>
```

### 路由的默认值和修改history规则  
用户直接进入首页时，默认进入首页。在routers里再配置一个选项：  
```js  
const routes = [
    {
        path: "/",       // 缺省的时候重定向 /加不加都可以
        redirect: "/home"
    }
]

```

使用html5的history修改，默认情况下是哈希模式，会出现/#/home，那么在new VueRouter创建时修改：  
```js  
const router = new VueRouter({
    routes,
    mode: "history",
})
```  

router-link 默认渲染成\<a\>标签， 通过设置tag属性可以渲染成其他的组件，例如\<router-link to="/home" tag="button" \>

replace属性使其不能前后回退，例如： \<router-link to="/home" tag="button"  replace\>

当点击了router-link后，class会多一个router-link-active的类。


## 通过代码跳转路由  
```js  
<button v-on:click="homeClick"></button>  
<button v-on:click="aboutClick"></button>
<script>
export default {
    name: "App",
    methods: {
        homeClick() {
            // this 表示当前组件对象
            // push ==> pushState
            this.$router.push("/home");
            // 或者选择用replace这种方法
            this.$router.replace("/home")
        },
        aboutClick(){
            this.$router.push("/about");
        }
    }
}
</script>
```  

### 动态路由  
在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：  
/user/aaa或/user/bbb  
除了有前面的/user之外，后面还跟上了用户ID  
这种path和Component的匹配关系，我们称之为动态路由，也是路由传递数据的一种方式。  

在src/router/index.js 里配置路由这样写：  
```js  
{
    path: "/user/:userId",
    component: User,
}
```  
在组件里的html router-link这样写：  
```html  
<router-link to="/user/zhangsan"> </router-link>
```  
实际上可能是动态获取的userid，比如：  
```html  
<router-link v-bind:to="'/user/'+userId"> </router-link>  

<script>
export default {
    name: "App",
    data() {
        return {
            userId: "zhangsan",
        }
    }
}
</script>
```

让跳转到的界面获取到userId信息：  
(注意和$route进行区别)  
```js  
// this.$route是当前活跃页面的路由， this.$router是获取的全局的router对象
this.$route.params.userId
```

### 路由的懒加载
目标：一个路由打包一个js文件，而不是一起打包。 只有在路由被访问到的时候再加载对应的组件。  

方式一（过时的写法）：  
结合Vue的异步组件和webpack的代码分析  
```js  
const Home = resolve => {require.ensure(['../components/Home.vue'], () => {resolve(require('../components/Home.vue'))})};  
```  
方式二（AMD写法）：  
```js  
const About = resolve => require(['../components/About.vue'], resolve);  
```    
方式三(ES6中，更简单写法来组织Vue异步组件和Webpack的代码分割)：  
```js  
const Home = () => import('../components/Home.vue');
```  

修改src/router/index.js写法：  
```js  
const routes = [
    {
        path: "/home",
        component: () => import("../components/Home"),
    },
    {
        path: "/about",
        component: () => import("../components/About"),
    }
]  

```  

### 路由的嵌套  
也就是在/home页面中，我们希望通过/home/news和/home/message访问一些内容，一个路径映射一个组件，访问这两个路径分别会渲染两个组件。

方法：  
创建对应的子组件，并且在路由映射中配置对应的子路由。  
在组件内部使用\<router-view\>标签  

index.js:  
```js  
const routes = [
    {
        path: "",
        redirect: "/home",
    },  
    {
        path: "/home",  
        component: Home, 
        children: [
            {
                path: "",               // 默认路径
                redirect: "news"
            },
            {
                path: "news",           //不需要加斜杠/  
                component: () => import("../components/HomeNews.vue"),
            },  
            {
                path: "message",
                component: () => import("../components/HomeMessages.vue");

            }
        ]
    }
]
```  

然后指明在哪里渲染加载。注意，需要在首页Home.vue里添加\<router-view\>和\<router-link\>  
Home.vue:  
```js  
<template>
<div>
    <h2>标题</h2>  
    <router-link to="/home/news">新闻</router-link>  
    <router-link to="/home/message">消息</router-link>  

    <router-view></router-view>
</div>
</template>
```

### 路由页面传递参数  

传递参数的方式：  
* params: /router/:id， 在path后面跟上对应的值，然后$route.params.id获取  
* query: 
    配置路由时：  /router，普通配置  
    传递方式：对象中使用query的key作为传递方式
    传递后形成的路径：/router?id=123  


query:  
routes就正常配置  

App.vue:  
```html  
<router-link v-bind:to="{path: '/profile', query: {name: 'why', age: 18}}"></router-link>
```  

活动页面获取query参数：  
```js  
{{$route.query}}
//或者  
this.$route.query
```  

通过button跳转：  
```js  
methods: {
    userClick(){
        this.$router.push("/user"+this.userId);  
    },
    profileCLick(){
        this.$router.push({
            path: "/profile",  
            query: {
                name: "why",
                height: 1.88
            }
        })
    }
}
```  

### \$route和\$router有区别  
```js
// $router全局都一样，就是一开始导入的 new VueRouter 对象。  
// this.$route是当前活跃页面的配置的路由对象
```  

### 导航守卫  
监听从哪里跳转到哪里的跳转过程，因为跳转过程中想要做一些中间操作。在对应的某一个监听函数里做一些事情。  

router.beforEach(func)方法可以在跳转前执行。
传入一个箭头函数，含有三个参数的箭头函数。
```js      
func: {  
    to: Route,    
    from: Route, 
    next: (to?:RawLocation | false | void |)  
} => Any  

routes = [{
    meta: {
        title: "首页",
    }
    path: "/home",
    component: Home
}]

router.beforeEach((to, from, next)=> {
    // 从from 跳转到to
    document.title = to.matched[0].meta.title;
    next();         // 要继续往下走，因为内部还有继续其他流程，当然还可以next('/user')，跳转到其他地方
})
```
beforeEach也称为前置钩子，回调。  
后置钩子afterEach表示路由跳转完之后调用

上面的是全局守卫，只要进行路由跳转都会执行。还有路由独享守卫和组件内的守卫。  

**路由独享守卫**：  
```js  
const router = new VueRouter({
    routes: [
        {
            path: "/foo",  
            component: Foo,  
            beforeEnter: (to, from, next) => {
                // ...

            }
        }
    ]
})
```  

**组件内守卫**：  
```js  
const Foo = {
    template: `...`,  
    beforeRouterEnter (to, from, next){

    },  
    beforeRouteUpdate(to, from, next){

    },  
    beforeRouteLeave(to, from, next){

    }
}
```  

### keep-alive 与Vue Router  
keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免被重新渲染。  
router-view 是一个组件，如果直接包在keep-alive里面，所有路径匹配到的视图组件都会被缓存；  

每次路由跳转，都会被销毁和创建，而keep-alive则不会出现这种情况，创建完毕后路由前进或后退时都不重新创建重新创建。  

```html  
<keep-alive>
    <router-view/>
</keep-alive>    
```  
在有keep-alive时，会有两个回调函数activate、deactivate，否则是没有的。  

keep-alive的两个重要的属性：  
include: 字符串或正则表达式，只有匹配的组件会被缓存(取决于name)  
exclude: 字符串或正则表达式，任何匹配的组件都不会被缓存。  
router-view也是一个组件，包含在keep-alive里则会被缓存。

```html  
<keep-alive exclude="User">
    <router-view/>
</keep-alive>    
```  



